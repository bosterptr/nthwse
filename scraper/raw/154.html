<html lang="en"><head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="wot-verification" content="9774b1ec7afc9c9aabd2">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Volatility, my own cheatsheet (Part 1): Image Identification | Andrea Fortuna</title>
<meta name="generator" content="Jekyll v4.2.1">
<meta property="og:title" content="Volatility, my own cheatsheet (Part 1): Image Identification">
<meta property="og:locale" content="en_US">
<meta name="description" content="In order to start a memory analysis with Volatility, the identification of the type of memory image is a mandatory step. Here some usefull commands. imageinfo For a high level summary of the memory sample you’re analyzing, use the imageinfo command. Most often this command is used to identify the operating system, service pack, and hardware architecture (32 or 64 bit), but it also contains other useful information such as the DTB address and time the sample was collected. $ vol.py -f ~/Desktop/win7_trial_64bit.raw imageinfo Volatility Foundation Volatility Framework 2.4 Determining profile based on KDBG search... Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64 AS Layer1 : AMD64PagedMemory (Kernel AS) AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw) PAE type : PAE DTB : 0x187000L KDBG : 0xf80002803070 Number of Processors : 1 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0xfffff80002804d00L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2012-02-22 11:29:02 UTC+0000 Image local date and time : 2012-02-22 03:29:02 -0800 The imageinfo output tells you the suggested profile that you should pass as the parameter to&nbsp;--profile=PROFILE&nbsp;when using other plugins. There may be more than one profile suggestion if profiles are closely related. It also prints the address of the KDBG (short for&nbsp;_KDDEBUGGER_DATA64) structure that will be used by plugins like pslist and modules to find the process and module list heads, respectively. In some cases, especially larger memory samples, there may be multiple KDBG structures. Similarly, if there are multiple processors, you'll see the KPCR address and CPU number for each one. Plugins automatically scan for the KPCR and KDBG values when they need them. However, you can specify the values directly for any plugin by providing&nbsp;--kpcr=ADDRESS&nbsp;or&nbsp;--kdbg=ADDRESS. By supplying the profile and KDBG (or failing that KPCR) to other Volatility commands, you'll get the most accurate and fastest results possible. Note:&nbsp;The&nbsp;imageinfo&nbsp;plugin will not work on hibernation files unless the correct profile is given in advance. This is because important structure definitions vary between different operating systems. kdbgscan As opposed to imageinfo which simply provides profile suggestions, kdbgscan is designed to positively identify the correct profile and the correct KDBG address (if there happen to be multiple). This plugin scans for the KDBGHeader signatures linked to Volatility profiles and applies sanity checks to reduce false positives. The verbosity of the output and number of sanity checks that can be performed depends on whether Volatility can find a DTB, so if you already know the correct profile (or if you have a profile suggestion from imageinfo), then make sure you use it. Here’s an example scenario of when this plugin can be useful. You have a memory sample that you believe to be Windows 2003 SP2 x64, but&nbsp;pslist&nbsp;doesn’t show any processes. The&nbsp;pslist&nbsp;plugin relies on finding the process list head which is pointed to by KDBG. However, the plugin takes the&nbsp;first&nbsp;KDBG found in the memory sample, which is not always the&nbsp;best&nbsp;one. You may run into this problem if a KDBG with an invalid PsActiveProcessHead pointer is found earlier in a sample (i.e. at a lower physical offset) than the valid KDBG. Notice below how&nbsp;kdbgscan&nbsp;picks up two KDBG structures: an invalid one (with 0 processes and 0 modules) is found first at&nbsp;0xf80001172cb0and a valid one (with 37 processes and 116 modules) is found next at&nbsp;0xf80001175cf0. In order to &quot;fix&quot; pslist for this sample, you would simply need to supply the&nbsp;--kdbg=0xf80001175cf0&nbsp;to the&nbsp;plist&nbsp;plugin. $ vol.py -f Win2K3SP2x64-6f1bedec.vmem --profile=Win2003SP2x64 kdbgscan Volatility Foundation Volatility Framework 2.4 ************************************************** Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit) Offset (V) : 0xf80001172cb0 Offset (P) : 0x1172cb0 KDBG owner tag check : True Profile suggestion (KDBGHeader): Win2003SP2x64 Version64 : 0xf80001172c70 (Major: 15, Minor: 3790) Service Pack (CmNtCSDVersion) : 0 Build string (NtBuildLab) : T? PsActiveProcessHead : 0xfffff800011947f0 (0 processes) PsLoadedModuleList : 0xfffff80001197ac0 (0 modules) KernelBase : 0xfffff80001000000 (Matches MZ: True) Major (OptionalHeader) : 5 Minor (OptionalHeader) : 2 ************************************************** Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit) Offset (V) : 0xf80001175cf0 Offset (P) : 0x1175cf0 KDBG owner tag check : True Profile suggestion (KDBGHeader): Win2003SP2x64 Version64 : 0xf80001175cb0 (Major: 15, Minor: 3790) Service Pack (CmNtCSDVersion) : 2 Build string (NtBuildLab) : 3790.srv03_sp2_rtm.070216-1710 PsActiveProcessHead : 0xfffff800011977f0 (37 processes) PsLoadedModuleList : 0xfffff8000119aae0 (116 modules) KernelBase : 0xfffff80001000000 (Matches MZ: True) Major (OptionalHeader) : 5 Minor (OptionalHeader) : 2 KPCR : 0xfffff80001177000 (CPU 0) More info about KDBG: Finding Kernel Global Variables in Windows When performing memory analysis of Windows systems, there are a number of kernel variables that are extremely helpful…moyix.blogspot.it Identifying Memory Images Have you ever been given a memory image to examine and not known what OS it was? Or maybe you were told it was X when…gleeda.blogspot.it kpcrscan Use this command to scan for potential KPCR structures by checking for the self-referencing members as described by Finding Object Roots in Vista. On a multi-core system, each processor has its own KPCR. Therefore, you’ll see details for each processor, including IDT and GDT address; current, idle, and next threads; CPU number, vendor &amp; speed; and CR3 value. $ vol.py -f dang_win7_x64.raw --profile=Win7SP1x64 kpcrscan Volatility Foundation Volatility Framework 2.4 ************************************************** Offset (V) : 0xf800029ead00 Offset (P) : 0x29ead00 KdVersionBlock : 0x0 IDT : 0xfffff80000b95080 GDT : 0xfffff80000b95000 CurrentThread : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964) IdleThread : 0xfffff800029f8c40 TID 0 (Idle:0) Details : CPU 0 (GenuineIntel @ 2128 MHz) CR3/DTB : 0x1dcec000 ************************************************** Offset (V) : 0xf880009e7000 Offset (P) : 0x4d9e000 KdVersionBlock : 0x0 IDT : 0xfffff880009f2540 GDT : 0xfffff880009f24c0 CurrentThread : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964) IdleThread : 0xfffff880009f1f40 TID 0 (Idle:0) Details : CPU 1 (GenuineIntel @ 2220 MHz) CR3/DTB : 0x1dcec000 If the&nbsp;KdVersionBlock&nbsp;is not null, then it may be possible to find the machine's KDBG address via the KPCR. In fact, the backup method of finding KDBG used by plugins such as pslist is to leverage&nbsp;kpcrscan&nbsp;and then call the&nbsp;KPCR.get_kdbg()&nbsp;API function. References The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory Memory forensics provides cutting edge technology to help investigate digital attacks Memory forensics is the art of…www.amazon.it volatilityfoundation/volatility volatility — An advanced memory forensics frameworkgithub.com">
<meta property="og:description" content="In order to start a memory analysis with Volatility, the identification of the type of memory image is a mandatory step. Here some usefull commands. imageinfo For a high level summary of the memory sample you’re analyzing, use the imageinfo command. Most often this command is used to identify the operating system, service pack, and hardware architecture (32 or 64 bit), but it also contains other useful information such as the DTB address and time the sample was collected. $ vol.py -f ~/Desktop/win7_trial_64bit.raw imageinfo Volatility Foundation Volatility Framework 2.4 Determining profile based on KDBG search... Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64 AS Layer1 : AMD64PagedMemory (Kernel AS) AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw) PAE type : PAE DTB : 0x187000L KDBG : 0xf80002803070 Number of Processors : 1 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0xfffff80002804d00L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2012-02-22 11:29:02 UTC+0000 Image local date and time : 2012-02-22 03:29:02 -0800 The imageinfo output tells you the suggested profile that you should pass as the parameter to&nbsp;--profile=PROFILE&nbsp;when using other plugins. There may be more than one profile suggestion if profiles are closely related. It also prints the address of the KDBG (short for&nbsp;_KDDEBUGGER_DATA64) structure that will be used by plugins like pslist and modules to find the process and module list heads, respectively. In some cases, especially larger memory samples, there may be multiple KDBG structures. Similarly, if there are multiple processors, you'll see the KPCR address and CPU number for each one. Plugins automatically scan for the KPCR and KDBG values when they need them. However, you can specify the values directly for any plugin by providing&nbsp;--kpcr=ADDRESS&nbsp;or&nbsp;--kdbg=ADDRESS. By supplying the profile and KDBG (or failing that KPCR) to other Volatility commands, you'll get the most accurate and fastest results possible. Note:&nbsp;The&nbsp;imageinfo&nbsp;plugin will not work on hibernation files unless the correct profile is given in advance. This is because important structure definitions vary between different operating systems. kdbgscan As opposed to imageinfo which simply provides profile suggestions, kdbgscan is designed to positively identify the correct profile and the correct KDBG address (if there happen to be multiple). This plugin scans for the KDBGHeader signatures linked to Volatility profiles and applies sanity checks to reduce false positives. The verbosity of the output and number of sanity checks that can be performed depends on whether Volatility can find a DTB, so if you already know the correct profile (or if you have a profile suggestion from imageinfo), then make sure you use it. Here’s an example scenario of when this plugin can be useful. You have a memory sample that you believe to be Windows 2003 SP2 x64, but&nbsp;pslist&nbsp;doesn’t show any processes. The&nbsp;pslist&nbsp;plugin relies on finding the process list head which is pointed to by KDBG. However, the plugin takes the&nbsp;first&nbsp;KDBG found in the memory sample, which is not always the&nbsp;best&nbsp;one. You may run into this problem if a KDBG with an invalid PsActiveProcessHead pointer is found earlier in a sample (i.e. at a lower physical offset) than the valid KDBG. Notice below how&nbsp;kdbgscan&nbsp;picks up two KDBG structures: an invalid one (with 0 processes and 0 modules) is found first at&nbsp;0xf80001172cb0and a valid one (with 37 processes and 116 modules) is found next at&nbsp;0xf80001175cf0. In order to &quot;fix&quot; pslist for this sample, you would simply need to supply the&nbsp;--kdbg=0xf80001175cf0&nbsp;to the&nbsp;plist&nbsp;plugin. $ vol.py -f Win2K3SP2x64-6f1bedec.vmem --profile=Win2003SP2x64 kdbgscan Volatility Foundation Volatility Framework 2.4 ************************************************** Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit) Offset (V) : 0xf80001172cb0 Offset (P) : 0x1172cb0 KDBG owner tag check : True Profile suggestion (KDBGHeader): Win2003SP2x64 Version64 : 0xf80001172c70 (Major: 15, Minor: 3790) Service Pack (CmNtCSDVersion) : 0 Build string (NtBuildLab) : T? PsActiveProcessHead : 0xfffff800011947f0 (0 processes) PsLoadedModuleList : 0xfffff80001197ac0 (0 modules) KernelBase : 0xfffff80001000000 (Matches MZ: True) Major (OptionalHeader) : 5 Minor (OptionalHeader) : 2 ************************************************** Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit) Offset (V) : 0xf80001175cf0 Offset (P) : 0x1175cf0 KDBG owner tag check : True Profile suggestion (KDBGHeader): Win2003SP2x64 Version64 : 0xf80001175cb0 (Major: 15, Minor: 3790) Service Pack (CmNtCSDVersion) : 2 Build string (NtBuildLab) : 3790.srv03_sp2_rtm.070216-1710 PsActiveProcessHead : 0xfffff800011977f0 (37 processes) PsLoadedModuleList : 0xfffff8000119aae0 (116 modules) KernelBase : 0xfffff80001000000 (Matches MZ: True) Major (OptionalHeader) : 5 Minor (OptionalHeader) : 2 KPCR : 0xfffff80001177000 (CPU 0) More info about KDBG: Finding Kernel Global Variables in Windows When performing memory analysis of Windows systems, there are a number of kernel variables that are extremely helpful…moyix.blogspot.it Identifying Memory Images Have you ever been given a memory image to examine and not known what OS it was? Or maybe you were told it was X when…gleeda.blogspot.it kpcrscan Use this command to scan for potential KPCR structures by checking for the self-referencing members as described by Finding Object Roots in Vista. On a multi-core system, each processor has its own KPCR. Therefore, you’ll see details for each processor, including IDT and GDT address; current, idle, and next threads; CPU number, vendor &amp; speed; and CR3 value. $ vol.py -f dang_win7_x64.raw --profile=Win7SP1x64 kpcrscan Volatility Foundation Volatility Framework 2.4 ************************************************** Offset (V) : 0xf800029ead00 Offset (P) : 0x29ead00 KdVersionBlock : 0x0 IDT : 0xfffff80000b95080 GDT : 0xfffff80000b95000 CurrentThread : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964) IdleThread : 0xfffff800029f8c40 TID 0 (Idle:0) Details : CPU 0 (GenuineIntel @ 2128 MHz) CR3/DTB : 0x1dcec000 ************************************************** Offset (V) : 0xf880009e7000 Offset (P) : 0x4d9e000 KdVersionBlock : 0x0 IDT : 0xfffff880009f2540 GDT : 0xfffff880009f24c0 CurrentThread : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964) IdleThread : 0xfffff880009f1f40 TID 0 (Idle:0) Details : CPU 1 (GenuineIntel @ 2220 MHz) CR3/DTB : 0x1dcec000 If the&nbsp;KdVersionBlock&nbsp;is not null, then it may be possible to find the machine's KDBG address via the KPCR. In fact, the backup method of finding KDBG used by plugins such as pslist is to leverage&nbsp;kpcrscan&nbsp;and then call the&nbsp;KPCR.get_kdbg()&nbsp;API function. References The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory Memory forensics provides cutting edge technology to help investigate digital attacks Memory forensics is the art of…www.amazon.it volatilityfoundation/volatility volatility — An advanced memory forensics frameworkgithub.com">
<link rel="canonical" href="/2017/06/25/volatility-my-own-cheatsheet-part-1-image-identification/">
<meta property="og:url" content="/2017/06/25/volatility-my-own-cheatsheet-part-1-image-identification/">
<meta property="og:site_name" content="Andrea Fortuna">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-06-25T09:01:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Volatility, my own cheatsheet (Part 1): Image Identification">
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"Volatility, my own cheatsheet (Part 1): Image Identification","dateModified":"2017-06-25T09:01:00+00:00","datePublished":"2017-06-25T09:01:00+00:00","url":"/2017/06/25/volatility-my-own-cheatsheet-part-1-image-identification/","mainEntityOfPage":{"@type":"WebPage","@id":"/2017/06/25/volatility-my-own-cheatsheet-part-1-image-identification/"},"description":"In order to start a memory analysis with Volatility, the identification of the type of memory image is a mandatory step. Here some usefull commands. imageinfo For a high level summary of the memory sample you’re analyzing, use the imageinfo command. Most often this command is used to identify the operating system, service pack, and hardware architecture (32 or 64 bit), but it also contains other useful information such as the DTB address and time the sample was collected. $ vol.py -f ~/Desktop/win7_trial_64bit.raw imageinfo Volatility Foundation Volatility Framework 2.4 Determining profile based on KDBG search... Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64 AS Layer1 : AMD64PagedMemory (Kernel AS) AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw) PAE type : PAE DTB : 0x187000L KDBG : 0xf80002803070 Number of Processors : 1 Image Type (Service Pack) : 0 KPCR for CPU 0 : 0xfffff80002804d00L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2012-02-22 11:29:02 UTC+0000 Image local date and time : 2012-02-22 03:29:02 -0800 The imageinfo output tells you the suggested profile that you should pass as the parameter to --profile=PROFILE when using other plugins. There may be more than one profile suggestion if profiles are closely related. It also prints the address of the KDBG (short for _KDDEBUGGER_DATA64) structure that will be used by plugins like pslist and modules to find the process and module list heads, respectively. In some cases, especially larger memory samples, there may be multiple KDBG structures. Similarly, if there are multiple processors, you&#39;ll see the KPCR address and CPU number for each one. Plugins automatically scan for the KPCR and KDBG values when they need them. However, you can specify the values directly for any plugin by providing --kpcr=ADDRESS or --kdbg=ADDRESS. By supplying the profile and KDBG (or failing that KPCR) to other Volatility commands, you&#39;ll get the most accurate and fastest results possible. Note: The imageinfo plugin will not work on hibernation files unless the correct profile is given in advance. This is because important structure definitions vary between different operating systems. kdbgscan As opposed to imageinfo which simply provides profile suggestions, kdbgscan is designed to positively identify the correct profile and the correct KDBG address (if there happen to be multiple). This plugin scans for the KDBGHeader signatures linked to Volatility profiles and applies sanity checks to reduce false positives. The verbosity of the output and number of sanity checks that can be performed depends on whether Volatility can find a DTB, so if you already know the correct profile (or if you have a profile suggestion from imageinfo), then make sure you use it. Here’s an example scenario of when this plugin can be useful. You have a memory sample that you believe to be Windows 2003 SP2 x64, but pslist doesn’t show any processes. The pslist plugin relies on finding the process list head which is pointed to by KDBG. However, the plugin takes the first KDBG found in the memory sample, which is not always the best one. You may run into this problem if a KDBG with an invalid PsActiveProcessHead pointer is found earlier in a sample (i.e. at a lower physical offset) than the valid KDBG. Notice below how kdbgscan picks up two KDBG structures: an invalid one (with 0 processes and 0 modules) is found first at 0xf80001172cb0and a valid one (with 37 processes and 116 modules) is found next at 0xf80001175cf0. In order to &quot;fix&quot; pslist for this sample, you would simply need to supply the --kdbg=0xf80001175cf0 to the plist plugin. $ vol.py -f Win2K3SP2x64-6f1bedec.vmem --profile=Win2003SP2x64 kdbgscan Volatility Foundation Volatility Framework 2.4 ************************************************** Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit) Offset (V) : 0xf80001172cb0 Offset (P) : 0x1172cb0 KDBG owner tag check : True Profile suggestion (KDBGHeader): Win2003SP2x64 Version64 : 0xf80001172c70 (Major: 15, Minor: 3790) Service Pack (CmNtCSDVersion) : 0 Build string (NtBuildLab) : T? PsActiveProcessHead : 0xfffff800011947f0 (0 processes) PsLoadedModuleList : 0xfffff80001197ac0 (0 modules) KernelBase : 0xfffff80001000000 (Matches MZ: True) Major (OptionalHeader) : 5 Minor (OptionalHeader) : 2 ************************************************** Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit) Offset (V) : 0xf80001175cf0 Offset (P) : 0x1175cf0 KDBG owner tag check : True Profile suggestion (KDBGHeader): Win2003SP2x64 Version64 : 0xf80001175cb0 (Major: 15, Minor: 3790) Service Pack (CmNtCSDVersion) : 2 Build string (NtBuildLab) : 3790.srv03_sp2_rtm.070216-1710 PsActiveProcessHead : 0xfffff800011977f0 (37 processes) PsLoadedModuleList : 0xfffff8000119aae0 (116 modules) KernelBase : 0xfffff80001000000 (Matches MZ: True) Major (OptionalHeader) : 5 Minor (OptionalHeader) : 2 KPCR : 0xfffff80001177000 (CPU 0) More info about KDBG: Finding Kernel Global Variables in Windows When performing memory analysis of Windows systems, there are a number of kernel variables that are extremely helpful…moyix.blogspot.it Identifying Memory Images Have you ever been given a memory image to examine and not known what OS it was? Or maybe you were told it was X when…gleeda.blogspot.it kpcrscan Use this command to scan for potential KPCR structures by checking for the self-referencing members as described by Finding Object Roots in Vista. On a multi-core system, each processor has its own KPCR. Therefore, you’ll see details for each processor, including IDT and GDT address; current, idle, and next threads; CPU number, vendor &amp; speed; and CR3 value. $ vol.py -f dang_win7_x64.raw --profile=Win7SP1x64 kpcrscan Volatility Foundation Volatility Framework 2.4 ************************************************** Offset (V) : 0xf800029ead00 Offset (P) : 0x29ead00 KdVersionBlock : 0x0 IDT : 0xfffff80000b95080 GDT : 0xfffff80000b95000 CurrentThread : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964) IdleThread : 0xfffff800029f8c40 TID 0 (Idle:0) Details : CPU 0 (GenuineIntel @ 2128 MHz) CR3/DTB : 0x1dcec000 ************************************************** Offset (V) : 0xf880009e7000 Offset (P) : 0x4d9e000 KdVersionBlock : 0x0 IDT : 0xfffff880009f2540 GDT : 0xfffff880009f24c0 CurrentThread : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964) IdleThread : 0xfffff880009f1f40 TID 0 (Idle:0) Details : CPU 1 (GenuineIntel @ 2220 MHz) CR3/DTB : 0x1dcec000 If the KdVersionBlock is not null, then it may be possible to find the machine&#39;s KDBG address via the KPCR. In fact, the backup method of finding KDBG used by plugins such as pslist is to leverage kpcrscan and then call the KPCR.get_kdbg() API function. References The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory Memory forensics provides cutting edge technology to help investigate digital attacks Memory forensics is the art of…www.amazon.it volatilityfoundation/volatility volatility — An advanced memory forensics frameworkgithub.com","@context":"https://schema.org"}</script>

<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Andrea Fortuna"></head>
<body><header class="site-header" role="banner">
<div class="wrapper"><a class="site-title" rel="author" href="/">Andrea Fortuna</a><nav class="site-nav">
<input type="checkbox" id="nav-trigger" class="nav-trigger">
<label for="nav-trigger">
<span class="menu-icon">
<svg viewBox="0 0 18 15" width="18px" height="15px">
<path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
</svg>
</span>
</label>
<div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/feed.xml">Rss</a>
<a class="page-link" href="https://liberapay.com/andreafortuna/donate"><img alt="Donate using Liberapay" src="https://liberapay.com/assets/widgets/donate.svg"></a>
</div>
</nav></div>
</header>
<main class="page-content" aria-label="Content">
<div class="wrapper">
<article class="post h-entry" itemscope="" itemtype="http://schema.org/BlogPosting">
<header class="post-header">
<h1 class="post-title p-name" itemprop="name headline">Volatility, my own cheatsheet (Part 1): Image Identification</h1>
<p class="post-meta">
<time class="dt-published" datetime="2017-06-25T09:01:00+00:00" itemprop="datePublished">Jun 25, 2017
</time>
</p></header>
<div class="post-content e-content" itemprop="articleBody">
<section class="section section--body section--first">
<div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<p id="c0b6" class="graf graf--p graf-after--figure">In order to start a memory analysis with Volatility, the identification of the type of memory image is a mandatory step.<br>
Here some usefull commands.</p>
<h4 id="b8c7" class="graf graf--h4 graf-after--p">imageinfo</h4>
<p id="b478" class="graf graf--p graf-after--h4">For a high level summary of the memory sample you’re analyzing, use the imageinfo command. Most often this command is used to identify the operating system, service pack, and hardware architecture (32 or 64 bit), but it also contains other useful information such as the DTB address and time the sample was collected.</p>
<pre id="957f" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ vol.py -f ~/Desktop/win7_trial_64bit.raw imageinfo
Volatility Foundation Volatility Framework 2.4
Determining profile based on KDBG search...</code></pre>
<pre id="58d8" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">Suggested Profile(s) : Win7SP0x64, Win7SP1x64, Win2008R2SP0x64, Win2008R2SP1x64
                     AS Layer1 : AMD64PagedMemory (Kernel AS)
                     AS Layer2 : FileAddressSpace (/Users/Michael/Desktop/win7_trial_64bit.raw)
                      PAE type : PAE
                           DTB : 0x187000L
                          KDBG : 0xf80002803070
          Number of Processors : 1
     Image Type (Service Pack) : 0
                KPCR for CPU 0 : 0xfffff80002804d00L
             KUSER_SHARED_DATA : 0xfffff78000000000L
           Image date and time : 2012-02-22 11:29:02 UTC+0000
     Image local date and time : 2012-02-22 03:29:02 -0800</code></pre>
<p id="88df" class="graf graf--p graf-after--pre">The imageinfo output tells you the suggested profile that you should pass as the parameter to&nbsp;<code>--profile=PROFILE</code>&nbsp;when using other plugins. There may be more than one profile suggestion if profiles are closely related. It also prints the address of the KDBG (short for&nbsp;<code>_KDDEBUGGER_DATA64</code>) structure that will be used by plugins like pslist and modules to find the process and module list heads, respectively. In some cases, especially larger memory samples, there may be multiple KDBG structures. Similarly, if there are multiple processors, you'll see the KPCR address and CPU number for each one.</p>
<p id="e88c" class="graf graf--p graf-after--p">Plugins automatically scan for the KPCR and KDBG values when they need them. However, you can specify the values directly for any plugin by providing&nbsp;<code>--kpcr=ADDRESS</code>&nbsp;or&nbsp;<code>--kdbg=ADDRESS</code>. By supplying the profile and KDBG (or failing that KPCR) to other Volatility commands, you'll get the most accurate and fastest results possible.</p>
<p id="19c4" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">Note:</strong>&nbsp;The&nbsp;<code>imageinfo</code>&nbsp;plugin will not work on hibernation files unless the correct profile is given in advance. This is because important structure definitions vary between different operating systems.</p>
</div>
</div>
</section>
<section class="section section--body">
<div class="section-divider">
<hr class="section-divider">
</div>
<div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<h4 id="7edb" class="graf graf--h4 graf--leading">kdbgscan</h4>
<p id="1876" class="graf graf--p graf-after--h4">As opposed to imageinfo which simply provides profile suggestions, kdbgscan is designed to positively identify the correct profile and the correct KDBG address (if there happen to be multiple). This plugin scans for the KDBGHeader signatures linked to Volatility profiles and applies sanity checks to reduce false positives. The verbosity of the output and number of sanity checks that can be performed depends on whether Volatility can find a DTB, so if you already know the correct profile (or if you have a profile suggestion from imageinfo), then make sure you use it.</p>
<p id="5077" class="graf graf--p graf-after--p">Here’s an example scenario of when this plugin can be useful. You have a memory sample that you believe to be Windows 2003 SP2 x64, but&nbsp;<a class="markup--anchor markup--p-anchor" href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference#pslist" target="_blank" rel="noopener" data-href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference#pslist">pslist</a>&nbsp;doesn’t show any processes. The&nbsp;<code>pslist</code>&nbsp;plugin relies on finding the process list head which is pointed to by KDBG. However, the plugin takes the&nbsp;<em class="markup--em markup--p-em">first</em>&nbsp;KDBG found in the memory sample, which is not always the&nbsp;<em class="markup--em markup--p-em">best</em>&nbsp;one. You may run into this problem if a KDBG with an invalid PsActiveProcessHead pointer is found earlier in a sample (i.e. at a lower physical offset) than the valid KDBG.</p>
<p id="adad" class="graf graf--p graf-after--p">Notice below how&nbsp;<code>kdbgscan</code>&nbsp;picks up two KDBG structures: an invalid one (with 0 processes and 0 modules) is found first at&nbsp;<code>0xf80001172cb0</code>and a valid one (with 37 processes and 116 modules) is found next at&nbsp;<code>0xf80001175cf0</code>. In order to "fix" pslist for this sample, you would simply need to supply the&nbsp;<code>--kdbg=0xf80001175cf0</code>&nbsp;to the&nbsp;<code>plist</code>&nbsp;plugin.</p>
<pre id="96fb" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ vol.py -f Win2K3SP2x64-6f1bedec.vmem --profile=Win2003SP2x64 kdbgscan
Volatility Foundation Volatility Framework 2.4
**************************************************
Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit)
Offset (V)                    : 0xf80001172cb0
Offset (P)                    : 0x1172cb0
KDBG owner tag check          : True
Profile suggestion (KDBGHeader): Win2003SP2x64
Version64                     : 0xf80001172c70 (Major: 15, Minor: 3790)
Service Pack (CmNtCSDVersion) : 0
Build string (NtBuildLab)     : T?
PsActiveProcessHead           : 0xfffff800011947f0 (0 processes)
PsLoadedModuleList            : 0xfffff80001197ac0 (0 modules)
KernelBase                    : 0xfffff80001000000 (Matches MZ: True)
Major (OptionalHeader)        : 5
Minor (OptionalHeader)        : 2</code></pre>
<pre id="3f7a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">**************************************************
Instantiating KDBG using: Kernel AS Win2003SP2x64 (5.2.3791 64bit)
Offset (V)                    : 0xf80001175cf0
Offset (P)                    : 0x1175cf0
KDBG owner tag check          : True
Profile suggestion (KDBGHeader): Win2003SP2x64
Version64                     : 0xf80001175cb0 (Major: 15, Minor: 3790)
Service Pack (CmNtCSDVersion) : 2
Build string (NtBuildLab)     : 3790.srv03_sp2_rtm.070216-1710
PsActiveProcessHead           : 0xfffff800011977f0 (37 processes)
PsLoadedModuleList            : 0xfffff8000119aae0 (116 modules)
KernelBase                    : 0xfffff80001000000 (Matches MZ: True)
Major (OptionalHeader)        : 5
Minor (OptionalHeader)        : 2
KPCR                          : 0xfffff80001177000 (CPU 0)</code></pre>
<p id="4a1e" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">More info about KDBG:</strong></p>
<div id="4755" class="graf graf--mixtapeEmbed graf-after--p"><a class="markup--anchor markup--mixtapeEmbed-anchor" title="http://moyix.blogspot.it/2008/04/finding-kernel-global-variables-in.html" href="http://moyix.blogspot.it/2008/04/finding-kernel-global-variables-in.html" data-href="http://moyix.blogspot.it/2008/04/finding-kernel-global-variables-in.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Finding Kernel Global Variables in Windows</strong><br>
<em class="markup--em markup--mixtapeEmbed-em">When performing memory analysis of Windows systems, there are a number of kernel variables that are extremely helpful…</em>moyix.blogspot.it</a></div>
<div id="f0fb" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a class="markup--anchor markup--mixtapeEmbed-anchor" title="http://gleeda.blogspot.it/2010/12/identifying-memory-images.html" href="http://gleeda.blogspot.it/2010/12/identifying-memory-images.html" data-href="http://gleeda.blogspot.it/2010/12/identifying-memory-images.html"><strong class="markup--strong markup--mixtapeEmbed-strong">Identifying Memory Images</strong><br>
<em class="markup--em markup--mixtapeEmbed-em">Have you ever been given a memory image to examine and not known what OS it was? Or maybe you were told it was X when…</em>gleeda.blogspot.it</a></div>
</div>
</div>
</section>
<section class="section section--body">
<div class="section-divider">
<hr class="section-divider">
</div>
<div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<h4 id="e407" class="graf graf--h4 graf--leading">kpcrscan</h4>
<p id="36c4" class="graf graf--p graf-after--h4">Use this command to scan for potential KPCR structures by checking for the self-referencing members as described by Finding Object Roots in Vista. On a multi-core system, each processor has its own KPCR. Therefore, you’ll see details for each processor, including IDT and GDT address; current, idle, and next threads; CPU number, vendor &amp; speed; and CR3 value.</p>
<pre id="5b57" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code">$ vol.py -f dang_win7_x64.raw --profile=Win7SP1x64 kpcrscan
Volatility Foundation Volatility Framework 2.4
**************************************************
Offset (V)                    : 0xf800029ead00
Offset (P)                    : 0x29ead00
KdVersionBlock                : 0x0
IDT                           : 0xfffff80000b95080
GDT                           : 0xfffff80000b95000
CurrentThread                 : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964)
IdleThread                    : 0xfffff800029f8c40 TID 0 (Idle:0)
Details                       : CPU 0 (GenuineIntel @ 2128 MHz)
CR3/DTB                       : 0x1dcec000
**************************************************
Offset (V)                    : 0xf880009e7000
Offset (P)                    : 0x4d9e000
KdVersionBlock                : 0x0
IDT                           : 0xfffff880009f2540
GDT                           : 0xfffff880009f24c0
CurrentThread                 : 0xfffffa800cf694d0 TID 2148 (kd.exe:2964)
IdleThread                    : 0xfffff880009f1f40 TID 0 (Idle:0)
Details                       : CPU 1 (GenuineIntel @ 2220 MHz)
CR3/DTB                       : 0x1dcec000</code></pre>
<p id="7aaa" class="graf graf--p graf-after--pre graf--trailing">If the&nbsp;<code>KdVersionBlock</code>&nbsp;is not null, then it may be possible to find the machine's KDBG address via the KPCR. In fact, the backup method of finding KDBG used by plugins such as pslist is to leverage&nbsp;<code>kpcrscan</code>&nbsp;and then call the&nbsp;<code>KPCR.get_kdbg()</code>&nbsp;API function.</p>
</div>
</div>
</section>
<section class="section section--body section--last">
<div class="section-divider">
<hr class="section-divider">
</div>
<div class="section-content">
<div class="section-inner sectionLayout--insetColumn">
<h3 id="5259" class="graf graf--h3 graf--leading">References</h3>
<div id="aa40" class="graf graf--mixtapeEmbed graf-after--h3"><a class="markup--anchor markup--mixtapeEmbed-anchor" title="https://www.amazon.it/Art-Memory-Forensics-Detecting-Malware-ebook/dp/B00JUUZSQC/ref=as_li_ss_tl?ie=UTF8&amp;qid=1499507826&amp;sr=8-1&amp;keywords=memory+forensics&amp;linkCode=ll1&amp;tag=t0601-21&amp;linkId=45727fa8ff43a32ed9afb4fb53a0a42b" href="https://www.amazon.it/Art-Memory-Forensics-Detecting-Malware-ebook/dp/B00JUUZSQC/ref=as_li_ss_tl?ie=UTF8&amp;qid=1499507826&amp;sr=8-1&amp;keywords=memory+forensics&amp;linkCode=ll1&amp;tag=t0601-21&amp;linkId=45727fa8ff43a32ed9afb4fb53a0a42b" data-href="https://www.amazon.it/Art-Memory-Forensics-Detecting-Malware-ebook/dp/B00JUUZSQC/ref=as_li_ss_tl?ie=UTF8&amp;qid=1499507826&amp;sr=8-1&amp;keywords=memory+forensics&amp;linkCode=ll1&amp;tag=t0601-21&amp;linkId=45727fa8ff43a32ed9afb4fb53a0a42b"><strong class="markup--strong markup--mixtapeEmbed-strong">The Art of Memory Forensics: Detecting Malware and Threats in Windows, Linux, and Mac Memory</strong><br>
<em class="markup--em markup--mixtapeEmbed-em">Memory forensics provides cutting edge technology to help investigate digital attacks Memory forensics is the art of…</em>www.amazon.it</a></div>
<div id="f607" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference" href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference" data-href="https://github.com/volatilityfoundation/volatility/wiki/Command-Reference"><strong class="markup--strong markup--mixtapeEmbed-strong">volatilityfoundation/volatility</strong><br>
<em class="markup--em markup--mixtapeEmbed-em">volatility — An advanced memory forensics framework</em>github.com</a></div>
</div>
</div>
</section>
</div><a class="u-url" href="/2017/06/25/volatility-my-own-cheatsheet-part-1-image-identification/" hidden=""></a>
</article>
</div>
</main><footer class="site-footer h-card">
<data class="u-url" href="/"></data>
<div class="wrapper">
<h2 class="footer-heading">Andrea Fortuna</h2>
<div class="footer-col-wrapper">
<div class="footer-col footer-col-1">
<ul class="contact-list">
<li class="p-name">Andrea Fortuna</li><li><a class="u-email" href="mailto:andrea@andreafortuna.org">andrea@andreafortuna.org</a></li></ul>
</div>
<div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/andreafortuna"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">andreafortuna</span></a></li><li><a href="https://www.linkedin.com/in/andrea-fortuna"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">andrea-fortuna</span></a></li><li><a rel="me" href="https://mastodon.andreafortuna.org/@andrea"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#mastodon"></use></svg> <span class="username">andrea</span></a></li></ul>
</div>
<div class="footer-col footer-col-3">
<p>Cybersecurity expert, software developer, experienced digital forensic analyst, musician</p>
<p><a href="https://liberapay.com/andreafortuna/donate"><img alt="Donate using Liberapay" src="https://liberapay.com/assets/widgets/donate.svg"></a></p>
</div>
</div>
</div>
</footer>
<script defer="" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;04c75085471348638c412113df818cbd&quot;}" type="text/javascript"></script>

</body></html>