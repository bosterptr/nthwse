<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="/css/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <script src="/css/bootstrap/js/bootstrap.bundle.min.js"></script>
    <title>Volume 1, Issue 1</title>
    <link rel="stylesheet" href="/css/iacrcc.css">
    <link rel="icon" type="image/png" href="/favicon.ico">
    
<script>
  MathJax = {
     tex: {
       inlineMath: [['$', '$'], ['\\(', '\\)']],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEnvironments: false,
       processEscapes: true
     },
    "HTML-CSS": { linebreaks: { automatic: true } }
   };
  </script>
  
  <script id="MathJax-script" async="" src="/js/mathjax/tex-chtml.js"></script>
  <style>
   
   a.aopener::after {
     content: " ▾";
   }
   div.abstract p {
      margin-bottom: 0pt;
      padding-bottom: 1rem;
    }
    </style>

  <style type="text/css">.CtxtMenu_InfoClose {  top:.2em; right:.2em;}
.CtxtMenu_InfoContent {  overflow:auto; text-align:left; font-size:80%;  padding:.4em .6em; border:1px inset; margin:1em 0px;  max-height:20em; max-width:30em; background-color:#EEEEEE;  white-space:normal;}
.CtxtMenu_Info.CtxtMenu_MousePost {outline:none;}
.CtxtMenu_Info {  position:fixed; left:50%; width:auto; text-align:center;  border:3px outset; padding:1em 2em; background-color:#DDDDDD;  color:black;  cursor:default; font-family:message-box; font-size:120%;  font-style:normal; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 15px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius:15px;               /* Safari and Chrome */  -moz-border-radius:15px;                  /* Firefox */  -khtml-border-radius:15px;                /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */  filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color="gray", Positive="true"); /* IE */}
</style><style type="text/css">.CtxtMenu_MenuClose {  position:absolute;  cursor:pointer;  display:inline-block;  border:2px solid #AAA;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  font-family: "Courier New", Courier;  font-size:24px;  color:#F0F0F0}
.CtxtMenu_MenuClose span {  display:block; background-color:#AAA; border:1.5px solid;  border-radius:18px;  -webkit-border-radius: 18px;             /* Safari and Chrome */  -moz-border-radius: 18px;                /* Firefox */  -khtml-border-radius: 18px;              /* Konqueror */  line-height:0;  padding:8px 0 6px     /* may need to be browser-specific */}
.CtxtMenu_MenuClose:hover {  color:white!important;  border:2px solid #CCC!important}
.CtxtMenu_MenuClose:hover span {  background-color:#CCC!important}
.CtxtMenu_MenuClose:hover:focus {  outline:none}
</style><style type="text/css">.CtxtMenu_Menu {  position:absolute;  background-color:white;  color:black;  width:auto; padding:5px 0px;  border:1px solid #CCCCCC; margin:0; cursor:default;  font: menu; text-align:left; text-indent:0; text-transform:none;  line-height:normal; letter-spacing:normal; word-spacing:normal;  word-wrap:normal; white-space:nowrap; float:none; z-index:201;  border-radius: 5px;                     /* Opera 10.5 and IE9 */  -webkit-border-radius: 5px;             /* Safari and Chrome */  -moz-border-radius: 5px;                /* Firefox */  -khtml-border-radius: 5px;              /* Konqueror */  box-shadow:0px 10px 20px #808080;         /* Opera 10.5 and IE9 */  -webkit-box-shadow:0px 10px 20px #808080; /* Safari 3 & Chrome */  -moz-box-shadow:0px 10px 20px #808080;    /* Forefox 3.5 */  -khtml-box-shadow:0px 10px 20px #808080;  /* Konqueror */}
.CtxtMenu_MenuItem {  padding: 1px 2em;  background:transparent;}
.CtxtMenu_MenuArrow {  position:absolute; right:.5em; padding-top:.25em; color:#666666;  font-family: null; font-size: .75em}
.CtxtMenu_MenuActive .CtxtMenu_MenuArrow {color:white}
.CtxtMenu_MenuArrow.CtxtMenu_RTL {left:.5em; right:auto}
.CtxtMenu_MenuCheck {  position:absolute; left:.7em;  font-family: null}
.CtxtMenu_MenuCheck.CtxtMenu_RTL { right:.7em; left:auto }
.CtxtMenu_MenuRadioCheck {  position:absolute; left: .7em;}
.CtxtMenu_MenuRadioCheck.CtxtMenu_RTL {  right: .7em; left:auto}
.CtxtMenu_MenuInputBox {  padding-left: 1em; right:.5em; color:#666666;  font-family: null;}
.CtxtMenu_MenuInputBox.CtxtMenu_RTL {  left: .1em;}
.CtxtMenu_MenuComboBox {  left:.1em; padding-bottom:.5em;}
.CtxtMenu_MenuSlider {  left: .1em;}
.CtxtMenu_SliderValue {  position:absolute; right:.1em; padding-top:.25em; color:#333333;  font-size: .75em}
.CtxtMenu_SliderBar {  outline: none; background: #d3d3d3}
.CtxtMenu_MenuLabel {  padding: 1px 2em 3px 1.33em;  font-style:italic}
.CtxtMenu_MenuRule {  border-top: 1px solid #DDDDDD;  margin: 4px 3px;}
.CtxtMenu_MenuDisabled {  color:GrayText}
.CtxtMenu_MenuActive {  background-color: #606872;  color: white;}
.CtxtMenu_MenuDisabled:focus {  background-color: #E8E8E8}
.CtxtMenu_MenuLabel:focus {  background-color: #E8E8E8}
.CtxtMenu_ContextMenu:focus {  outline:none}
.CtxtMenu_ContextMenu .CtxtMenu_MenuItem:focus {  outline:none}
.CtxtMenu_SelectionMenu {  position:relative; float:left;  border-bottom: none; -webkit-box-shadow:none; -webkit-border-radius:0px; }
.CtxtMenu_SelectionItem {  padding-right: 1em;}
.CtxtMenu_Selection {  right: 40%; width:50%; }
.CtxtMenu_SelectionBox {  padding: 0em; max-height:20em; max-width: none;  background-color:#FFFFFF;}
.CtxtMenu_SelectionDivider {  clear: both; border-top: 2px solid #000000;}
.CtxtMenu_Menu .CtxtMenu_MenuClose {  top:-10px; left:-10px}
</style><style id="MJX-CHTML-styles">
mjx-container[jax="CHTML"] {
  line-height: 0;
}

mjx-container [space="1"] {
  margin-left: .111em;
}

mjx-container [space="2"] {
  margin-left: .167em;
}

mjx-container [space="3"] {
  margin-left: .222em;
}

mjx-container [space="4"] {
  margin-left: .278em;
}

mjx-container [space="5"] {
  margin-left: .333em;
}

mjx-container [rspace="1"] {
  margin-right: .111em;
}

mjx-container [rspace="2"] {
  margin-right: .167em;
}

mjx-container [rspace="3"] {
  margin-right: .222em;
}

mjx-container [rspace="4"] {
  margin-right: .278em;
}

mjx-container [rspace="5"] {
  margin-right: .333em;
}

mjx-container [size="s"] {
  font-size: 70.7%;
}

mjx-container [size="ss"] {
  font-size: 50%;
}

mjx-container [size="Tn"] {
  font-size: 60%;
}

mjx-container [size="sm"] {
  font-size: 85%;
}

mjx-container [size="lg"] {
  font-size: 120%;
}

mjx-container [size="Lg"] {
  font-size: 144%;
}

mjx-container [size="LG"] {
  font-size: 173%;
}

mjx-container [size="hg"] {
  font-size: 207%;
}

mjx-container [size="HG"] {
  font-size: 249%;
}

mjx-container [width="full"] {
  width: 100%;
}

mjx-box {
  display: inline-block;
}

mjx-block {
  display: block;
}

mjx-itable {
  display: inline-table;
}

mjx-row {
  display: table-row;
}

mjx-row > * {
  display: table-cell;
}

mjx-mtext {
  display: inline-block;
}

mjx-mstyle {
  display: inline-block;
}

mjx-merror {
  display: inline-block;
  color: red;
  background-color: yellow;
}

mjx-mphantom {
  visibility: hidden;
}

_::-webkit-full-page-media, _:future, :root mjx-container {
  will-change: opacity;
}

mjx-assistive-mml {
  position: absolute !important;
  top: 0px;
  left: 0px;
  clip: rect(1px, 1px, 1px, 1px);
  padding: 1px 0px 0px 0px !important;
  border: 0px !important;
  display: block !important;
  width: auto !important;
  overflow: hidden !important;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

mjx-assistive-mml[display="block"] {
  width: 100% !important;
}

mjx-math {
  display: inline-block;
  text-align: left;
  line-height: 0;
  text-indent: 0;
  font-style: normal;
  font-weight: normal;
  font-size: 100%;
  font-size-adjust: none;
  letter-spacing: normal;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  direction: ltr;
  padding: 1px 0;
}

mjx-container[jax="CHTML"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="CHTML"][display="true"][width="full"] {
  display: flex;
}

mjx-container[jax="CHTML"][display="true"] mjx-math {
  padding: 0;
}

mjx-container[jax="CHTML"][justify="left"] {
  text-align: left;
}

mjx-container[jax="CHTML"][justify="right"] {
  text-align: right;
}

mjx-mn {
  display: inline-block;
  text-align: left;
}

mjx-c {
  display: inline-block;
}

mjx-utext {
  display: inline-block;
  padding: .75em 0 .2em 0;
}

mjx-mo {
  display: inline-block;
  text-align: left;
}

mjx-stretchy-h {
  display: inline-table;
  width: 100%;
}

mjx-stretchy-h > * {
  display: table-cell;
  width: 0;
}

mjx-stretchy-h > * > mjx-c {
  display: inline-block;
  transform: scalex(1.0000001);
}

mjx-stretchy-h > * > mjx-c::before {
  display: inline-block;
  width: initial;
}

mjx-stretchy-h > mjx-ext {
  /* IE */ overflow: hidden;
  /* others */ overflow: clip visible;
  width: 100%;
}

mjx-stretchy-h > mjx-ext > mjx-c::before {
  transform: scalex(500);
}

mjx-stretchy-h > mjx-ext > mjx-c {
  width: 0;
}

mjx-stretchy-h > mjx-beg > mjx-c {
  margin-right: -.1em;
}

mjx-stretchy-h > mjx-end > mjx-c {
  margin-left: -.1em;
}

mjx-stretchy-v {
  display: inline-block;
}

mjx-stretchy-v > * {
  display: block;
}

mjx-stretchy-v > mjx-beg {
  height: 0;
}

mjx-stretchy-v > mjx-end > mjx-c {
  display: block;
}

mjx-stretchy-v > * > mjx-c {
  transform: scaley(1.0000001);
  transform-origin: left center;
  overflow: hidden;
}

mjx-stretchy-v > mjx-ext {
  display: block;
  height: 100%;
  box-sizing: border-box;
  border: 0px solid transparent;
  /* IE */ overflow: hidden;
  /* others */ overflow: visible clip;
}

mjx-stretchy-v > mjx-ext > mjx-c::before {
  width: initial;
  box-sizing: border-box;
}

mjx-stretchy-v > mjx-ext > mjx-c {
  transform: scaleY(500) translateY(.075em);
  overflow: visible;
}

mjx-mark {
  display: inline-block;
  height: 0px;
}

mjx-mi {
  display: inline-block;
  text-align: left;
}

mjx-TeXAtom {
  display: inline-block;
  text-align: left;
}

mjx-msub {
  display: inline-block;
  text-align: left;
}

mjx-msup {
  display: inline-block;
  text-align: left;
}

mjx-c::before {
  display: block;
  width: 0;
}

.MJX-TEX {
  font-family: MJXZERO, MJXTEX;
}

.TEX-B {
  font-family: MJXZERO, MJXTEX-B;
}

.TEX-I {
  font-family: MJXZERO, MJXTEX-I;
}

.TEX-MI {
  font-family: MJXZERO, MJXTEX-MI;
}

.TEX-BI {
  font-family: MJXZERO, MJXTEX-BI;
}

.TEX-S1 {
  font-family: MJXZERO, MJXTEX-S1;
}

.TEX-S2 {
  font-family: MJXZERO, MJXTEX-S2;
}

.TEX-S3 {
  font-family: MJXZERO, MJXTEX-S3;
}

.TEX-S4 {
  font-family: MJXZERO, MJXTEX-S4;
}

.TEX-A {
  font-family: MJXZERO, MJXTEX-A;
}

.TEX-C {
  font-family: MJXZERO, MJXTEX-C;
}

.TEX-CB {
  font-family: MJXZERO, MJXTEX-CB;
}

.TEX-FR {
  font-family: MJXZERO, MJXTEX-FR;
}

.TEX-FRB {
  font-family: MJXZERO, MJXTEX-FRB;
}

.TEX-SS {
  font-family: MJXZERO, MJXTEX-SS;
}

.TEX-SSB {
  font-family: MJXZERO, MJXTEX-SSB;
}

.TEX-SSI {
  font-family: MJXZERO, MJXTEX-SSI;
}

.TEX-SC {
  font-family: MJXZERO, MJXTEX-SC;
}

.TEX-T {
  font-family: MJXZERO, MJXTEX-T;
}

.TEX-V {
  font-family: MJXZERO, MJXTEX-V;
}

.TEX-VB {
  font-family: MJXZERO, MJXTEX-VB;
}

mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c {
  font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A ! important;
}

@font-face /* 0 */ {
  font-family: MJXZERO;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff");
}

@font-face /* 1 */ {
  font-family: MJXTEX;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff");
}

@font-face /* 2 */ {
  font-family: MJXTEX-B;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff");
}

@font-face /* 3 */ {
  font-family: MJXTEX-I;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff");
}

@font-face /* 4 */ {
  font-family: MJXTEX-MI;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff");
}

@font-face /* 5 */ {
  font-family: MJXTEX-BI;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff");
}

@font-face /* 6 */ {
  font-family: MJXTEX-S1;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff");
}

@font-face /* 7 */ {
  font-family: MJXTEX-S2;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff");
}

@font-face /* 8 */ {
  font-family: MJXTEX-S3;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff");
}

@font-face /* 9 */ {
  font-family: MJXTEX-S4;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff");
}

@font-face /* 10 */ {
  font-family: MJXTEX-A;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff");
}

@font-face /* 11 */ {
  font-family: MJXTEX-C;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff");
}

@font-face /* 12 */ {
  font-family: MJXTEX-CB;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff");
}

@font-face /* 13 */ {
  font-family: MJXTEX-FR;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff");
}

@font-face /* 14 */ {
  font-family: MJXTEX-FRB;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff");
}

@font-face /* 15 */ {
  font-family: MJXTEX-SS;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff");
}

@font-face /* 16 */ {
  font-family: MJXTEX-SSB;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff");
}

@font-face /* 17 */ {
  font-family: MJXTEX-SSI;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff");
}

@font-face /* 18 */ {
  font-family: MJXTEX-SC;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff");
}

@font-face /* 19 */ {
  font-family: MJXTEX-T;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff");
}

@font-face /* 20 */ {
  font-family: MJXTEX-V;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff");
}

@font-face /* 21 */ {
  font-family: MJXTEX-VB;
  src: url("https://cic.iacr.org/js/mathjax/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff");
}

mjx-c.mjx-c31::before {
  padding: 0.666em 0.5em 0 0;
  content: "1";
}

mjx-c.mjx-c2E::before {
  padding: 0.12em 0.278em 0 0;
  content: ".";
}

mjx-c.mjx-c35::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "5";
}

mjx-c.mjx-c34::before {
  padding: 0.677em 0.5em 0 0;
  content: "4";
}

mjx-c.mjx-c33::before {
  padding: 0.665em 0.5em 0.022em 0;
  content: "3";
}

mjx-c.mjx-c30::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "0";
}

mjx-c.mjx-c37::before {
  padding: 0.676em 0.5em 0.022em 0;
  content: "7";
}

mjx-c.mjx-cD7::before {
  padding: 0.491em 0.778em 0 0;
  content: "\D7";
}

mjx-c.mjx-c38::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "8";
}

mjx-c.mjx-c32::before {
  padding: 0.666em 0.5em 0 0;
  content: "2";
}

mjx-c.mjx-c39::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "9";
}

mjx-c.mjx-c1D461.TEX-I::before {
  padding: 0.626em 0.361em 0.011em 0;
  content: "t";
}

mjx-c.mjx-c3A3::before {
  padding: 0.683em 0.722em 0 0;
  content: "\3A3";
}

mjx-c.mjx-c3A0::before {
  padding: 0.68em 0.75em 0 0;
  content: "\3A0";
}

mjx-c.mjx-c1D5AD.TEX-SS::before {
  padding: 0.694em 0.708em 0 0;
  content: "N";
}

mjx-c.mjx-c1D5AF.TEX-SS::before {
  padding: 0.694em 0.639em 0 0;
  content: "P";
}

mjx-c.mjx-c7B::before {
  padding: 0.75em 0.5em 0.25em 0;
  content: "{";
}

mjx-c.mjx-c2C::before {
  padding: 0.121em 0.278em 0.194em 0;
  content: ",";
}

mjx-c.mjx-c7D::before {
  padding: 0.75em 0.5em 0.25em 0;
  content: "}";
}

mjx-c.mjx-c1D45D.TEX-I::before {
  padding: 0.442em 0.503em 0.194em 0;
  content: "p";
}

mjx-c.mjx-c2124.TEX-A::before {
  padding: 0.683em 0.667em 0 0;
  content: "Z";
}

mjx-c.mjx-c1D446.TEX-I::before {
  padding: 0.705em 0.645em 0.022em 0;
  content: "S";
}

mjx-c.mjx-c2B::before {
  padding: 0.583em 0.778em 0.082em 0;
  content: "+";
}

mjx-c.mjx-c1D45A.TEX-I::before {
  padding: 0.442em 0.878em 0.011em 0;
  content: "m";
}

mjx-c.mjx-c1D440.TEX-I::before {
  padding: 0.683em 1.051em 0 0;
  content: "M";
}

mjx-c.mjx-c36::before {
  padding: 0.666em 0.5em 0.022em 0;
  content: "6";
}
</style></head>

  <body>
    <noscript>
      <h1 class="text-center">What a lovely hat</h1>
      <h4 class="text-center">Is it made out of <a href="https://iacr.org/tinfoil.html">tin foil</a>?</h4>
    </noscript>
    <div class="pageTop d-flex justify-content-md-around justify-content-between align-items-center">
      <a href="https://iacr.org"><img id="logo" class="d-none d-lg-block ms-5" src="/images/iacrlogo_small.png" title="International Association for Cryptologic Research" alt="IACR logo"></a>
      <span class="headerTitle d-none d-md-block">Communications in Cryptology</span>
      <span class="headerTitle d-md-none">IACR CiC</span>
      <div class="dropdown ps-lg-2 me-5">
        <button class="btn border-0" type="button" id="dropdownMenuButton1" data-bs-toggle="dropdown" aria-expanded="true">
          <img src="/images/search.svg" class="searchIcon" alt="Search Button" style="width:33px;">
        </button>
        <div id="searchDd" class="dropdown-menu dropdown-menu-end bg-transparent border-0" aria-labelledby="dropdownMenuButton1" data-bs-popper="none">
          <form action="/search" method="GET" class="me-3">
            <div class="input-group">
              <input id="searchbox" name="q" type="search" class="form-control shadow-none" autocomplete="off">
              
              <button class="btn btn-outline-dark border border-dark input-group-append">
                Search
              </button>
            </div>
          </form>
          <div id="results" class="bg-light"></div>
          
        </div>
      </div>
    </div>
    <nav id="sitenav" class="navbar navbar-expand-md">
      <div class="container">
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#collapseContent" aria-controls="collapseContent" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="collapseContent">
          <ul class="navbar-nav nav-fill w-100 justify-content-between">
            <li class="nav-item">
              <a class="nav-link active" aria-current="page" href="/">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/contents">Papers</a>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                Submissions
              </a>
              <ul class="dropdown-menu ms-3 ms-lg-5">
                <li><a class="dropdown-item" href="/callforpapers">Call for papers</a></li>
                <li><a class="dropdown-item" href="/ethics">Publication ethics</a></li>
                <li><a class="dropdown-item" href="/irregular">Irregular submissions</a></li>
                <li><a class="dropdown-item" href="/conflicts">Conflict of interest</a></li>
                <li><a class="dropdown-item" href="/retraction">Retraction policy</a></li>
              </ul>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/faq">FAQ</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/contact">Contact</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="/board">Editorial board</a>
            </li>
            <li class="nav-item dropdown">
              <a href="#" class="ms-md-5 nav-link dropdown-toggle" data-bs-toggle="dropdown"><img alt="Login" src="/images/user.svg"></a>
              <ul class="dropdown-menu">
                
                <li><a href="/login" class="dropdown-item">Admin login</a></li>
                
              </ul>
            </li>
	  </ul>
        </div>
      </div>
    </nav>
    <main id="mainContent" class="container">
    

<nav aria-label="breadcrumb" class="my-3">
  <ol class="breadcrumb">
    <li class="breadcrumb-item"><a href="/">Home</a></li>
    <li class="breadcrumb-item"><a href="/v/1">Volume 1</a></li>
    <li class="breadcrumb-item">Issue 1</li>
  </ol>
</nav>
<div class="row">
  <div class="col-md-9 col-12">
    <h3 class="mt-2">Volume 1, Issue 1</h3>
    <h5 class="mb-4">Published 2024-04-09</h5>
    
    <div class="mb-5">
      <h5><a href="/p/1/1/1">Bit Security as Cost to Demonstrate Advantage</a></h5>
      <p><span class="fst-italic">Keewoo Lee</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-1" role="button" aria-expanded="false" aria-controls="abs-1">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/1/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-1" class="collapse abstract"><div><p>  We revisit the question of what the definition of bit security should be, previously answered by Micciancio-Walter (Eurocrypt 2018) and Watanabe-Yasunaga (Asiacrypt 2021). Our new definition is simple, but (i) captures both search and decision primitives in a single framework like Micciancio-Walter, and (ii) has a firm operational meaning like Watanabe-Yasunaga. It also matches intuitive expectations and can be well-formulated regarding Hellinger distance. To support and justify the new definition, we prove several classic security reductions with respect to our bit security. We also provide pathological examples that indicate the ill-definedness of bit security defined in Micciancio-Walter and Watanabe-Yasunaga. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/2">Proximity Testing with Logarithmic Randomness</a></h5>
      <p><span class="fst-italic">Benjamin E. Diamond, Jim Posen</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-2" role="button" aria-expanded="false" aria-controls="abs-2">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/2/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-2" class="collapse abstract"><div><p>A fundamental result dating to Ligero (Des. Codes Cryptogr. '23) establishes that each fixed linear block code exhibits proximity gaps with respect to the collection of affine subspaces, in the sense that each given subspace either resides entirely close to the code, or else contains only a small portion which resides close to the code. In particular, any given subspace's failure to reside entirely close to the code is necessarily witnessed, with high probability, by a uniformly randomly sampled element of that subspace. We investigate a variant of this phenomenon in which the witness is not sampled uniformly from the subspace, but rather from a much smaller subset of it. We show that a logarithmic number of random field elements (in the dimension of the subspace) suffice to effect an analogous proximity test, with moreover only a logarithmic (multiplicative) loss in the possible prevalence of false witnesses. We discuss applications to recent noninteractive proofs based on linear codes, including Brakedown (CRYPTO '23). </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/3">Verifiable Encryption from MPC-in-the-Head</a></h5>
      <p><span class="fst-italic">Akira Takahashi, Greg Zaverucha</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-3" role="button" aria-expanded="false" aria-controls="abs-3">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/3/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-3" class="collapse abstract"><div><p>        Verifiable encryption (VE) is a protocol where one can provide assurance that an encrypted plaintext satisfies certain properties, or relations.         It is an important building block in cryptography with many useful applications, such as key escrow, group signatures, optimistic fair exchange, and others.         However, the majority of previous VE schemes are restricted to instantiation with specific public-key encryption schemes or relations.                  In this work, we propose a novel framework that realizes VE protocols using zero-knowledge proof systems based on the MPC-in-the-head paradigm (Ishai et al. STOC 2007).         Our generic compiler can turn a large class of zero-knowledge proofs into secure VE protocols for any secure public-key encryption scheme with the undeniability property, a notion that essentially guarantees binding of encryption when used as a commitment scheme.                  Our framework is versatile: because the circuit proven by the MPC-in-the-head prover is decoupled from a complex encryption function, the work of the prover is focused on proving the encrypted data satisfies the relation, not the proof of plaintext knowledge.         Hence, our approach allows for instantiation with various combinations of properties about the encrypted data and encryption functions.         We then consider concrete applications, to demonstrate the efficiency of our framework, by first giving         a new approach and implementation to verifiably encrypt discrete logarithms in any prime order group more efficiently than was previously known.         Then we give the first practical verifiable encryption scheme for AES keys with post-quantum security, along with an implementation and benchmarks. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/4">Impossibility of Post-Quantum Shielding Black-Box Constructions of CCA from CPA</a></h5>
      <p><span class="fst-italic">Loïs Huguenin-Dumittan, Serge Vaudenay</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-4" role="button" aria-expanded="false" aria-controls="abs-4">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/4/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-4" class="collapse abstract"><div><p>        Proving whether it is possible to build IND-CCA public-key encryption (PKE) from IND-CPA PKE in a black-box manner is a major open problem in theoretical cryptography.  In a significant breakthrough, Gertner, Malkin and Myers showed in 2007 that shielding black-box reductions from IND-CCA to IND-CPA do not exist in the standard model. Shielding means that the decryption algorithm of the IND-CCA scheme does not call the encryption algorithm of the underlying IND-CPA scheme. In other words, it implies that every tentative construction of IND-CCA from IND-CPA must have a re-encryption step when decrypting.</p><p>        This result was only proven with respect to classical algorithms. In this work we show that it stands in a post-quantum setting. That is, we prove that there is no post-quantum shielding black-box construction of IND-CCA PKE from IND-CPA PKE. In the type of reductions we consider, i.e. post-quantum ones, the constructions are still classical in the sense that the schemes must be computable on classical computers, but the adversaries and the reduction algorithm can be quantum. This suggests that considering quantum notions, which are stronger than their classical counterparts, and allowing for quantum reductions does not make building IND-CCA public-key encryption easier. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/5">Optimizations and Practicality of High-Security CSIDH</a></h5>
      <p><span class="fst-italic">Fabio Campos, Jorge Chávez-Saab, Jesús-Javier Chi-Domínguez, Michael Meyer, Krijn Reijnders, Francisco Rodríguez-Henríquez, Peter Schwabe, Thom Wiggers</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-5" role="button" aria-expanded="false" aria-controls="abs-5">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/5/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-5" class="collapse abstract"><div><p>    In this work, we assess the real-world practicality of CSIDH, an isogeny-based non-interactive key exchange.     We provide the first thorough assessment of the practicality of CSIDH in higher parameter sizes     for conservative estimates of quantum security,     and with protection against physical attacks.</p><p>    This requires a three-fold analysis of CSIDH.     First, we describe two approaches to efficient high-security CSIDH implementations,     based on SQALE and CTIDH.     Second, we optimize such high-security implementations,     on a high level by improving several subroutines,     and on a low level by improving the finite field arithmetic.     Third, we benchmark the performance of high-security CSIDH.     As a stand-alone primitive, our implementations outperform previous     results by a factor up to 2.53×.</p><p>    As a real-world use case considering network protocols,     we use CSIDH in TLS variants that allow early authentication     through a NIKE.     Although our instantiations of CSIDH have smaller communication requirements than     post-quantum KEM and signature schemes, even our highly-optimized implementations result     in too-large handshake latency (tens of seconds), showing that CSIDH is only practical     in niche cases. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/6">Using Predicate Extension for Predicate Encryption to Generically Obtain Chosen-Ciphertext Security and Signatures</a></h5>
      <p><span class="fst-italic">Marloes Venema, Leon Botros</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-6" role="button" aria-expanded="false" aria-controls="abs-6">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/6/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-6" class="collapse abstract"><div><p>Predicate encryption (PE) is a type of public-key encryption that captures many useful primitives such as attribute-based encryption (ABE). Although much progress has been made to generically achieve security against chosen-plaintext attacks (CPA) efficiently, in practice, we also require security against chosen-ciphertext attacks (CCA). Because achieving CCA-security on a case-by-case basis is a complicated task, several generic conversion methods have been proposed, which typically target different subclasses of PE such as ciphertext-policy ABE. As is common, such conversion methods may sacrifice some efficiency. Notably, for ciphertext-policy ABE, all proposed generic transformations incur a significant decryption overhead. Furthermore, depending on the setting in which PE is used, we may also want to require that messages are signed. To do this, predicate signature schemes can be used. However, such schemes provide a strong notion of privacy for the signer, which may be stronger than necessary for some practical settings at the cost of efficiency.</p><p>In this work, we propose the notion of predicate extension, which transforms the predicate used in a PE scheme to include one additional attribute, in both the keys and the ciphertexts. Using predicate extension, we can generically obtain CCA-security and signatures from a CPA-secure PE scheme. For the CCA-security transform, we observe that predicate extension implies a two-step approach to achieving CCA-security. This insight broadens the applicability of existing transforms for specific subclasses of PE to cover all PE. We also propose a new transform that incurs slightly less overhead than existing transforms. Furthermore, we show that predicate extension allows us to create a new type of signatures, which we call PE-based signatures. PE-based signatures are weaker than typical predicate signatures in the sense that they do not provide privacy for the signer. Nevertheless, such signatures may be more suitable for some practical settings owing to their efficiency or reduced interactivity. Lastly, to show that predicate extensions may facilitate a more efficient way to achieve CCA-security generically than existing methods, we propose a novel predicate-extension transformation for a large class of pairing-based PE, covered by the pair and predicate encodings frameworks. In particular, this yields the most efficient generic CCA-conversion for ciphertext-policy ABE.</p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/7">A Survey of Two Verifiable Delay Functions   Using Proof of Exponentiation</a></h5>
      <p><span class="fst-italic">Dan Boneh, Benedikt Bünz, Ben Fisch</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-SOK">SoK paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-7" role="button" aria-expanded="false" aria-controls="abs-7">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/7/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-7" class="collapse abstract"><div><p>A verifiable delay function (VDF) is an important tool used for adding delay in decentralized applications. This paper surveys and compares two beautiful verifiable delay functions, one due to Pietrzak, and the other due to Wesolowski, In addition, we provide a new computational proof of security for one of them, present an attack on an incorrect implementation of the other, and compare the complexity assumptions needed for both schemes. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/8">On the Efficiency of Generic, Quantum Cryptographic Constructions</a></h5>
      <p><span class="fst-italic">Keita Xagawa</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-8" role="button" aria-expanded="false" aria-controls="abs-8">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/8/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-8" class="collapse abstract"><div><p>One of the central questions in cryptology is how efficient generic constructions of cryptographic primitives can be. Gennaro, Gertner, Katz, and Trevisan [SIAM J. of Compt., 2005] studied the lower bounds of the number of invocations of a (trapdoor) one-way permutation in order to construct cryptographic schemes, e.g., pseudorandom number generators, digital signatures, and public-key and symmetric-key encryption.</p><p>Recently, quantum machines have been explored to _construct_ cryptographic primitives other than quantum key distribution. This paper studies the efficiency of _quantum_ black-box constructions of cryptographic primitives when the communications are _classical_. Following Gennaro et al., we give the lower bounds of the number of invocations of an underlying quantumly-computable quantum-one-way permutation when the _quantum_ construction of pseudorandom number generator and symmetric-key encryption is weakly black-box. Our results show that the quantum black-box constructions of pseudorandom number generator and symmetric-key encryption do not improve the number of invocations of an underlying quantumly-computable quantum-one-way permutation. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/9">Fast polynomial multiplication using matrix multiplication accelerators with applications to NTRU on Apple M1/M3 SoCs</a></h5>
      <p><span class="fst-italic">Décio Luiz Gazzoni Filho, Guilherme Brandão, Julio López</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-9" role="button" aria-expanded="false" aria-controls="abs-9">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/9/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-9" class="collapse abstract"><div><p>Efficient polynomial multiplication routines are critical to the performance of lattice-based post-quantum cryptography (PQC). As PQC standards only recently started to emerge, CPUs still lack specialized instructions to accelerate such routines. Meanwhile, deep learning has grown immeasurably in importance. Its workloads call for teraflops-level of processing power for linear algebra operations, mainly matrix multiplication. Computer architects have responded by introducing ISA extensions, coprocessors and special-purpose cores to accelerate such operations. In particular, Apple ships an undocumented matrix-multiplication coprocessor, AMX, in hundreds of millions of mobile phones, tablets and personal computers. Our work repurposes AMX to implement polynomial multiplication and applies it to the NTRU cryptosystem, setting new speed records on the Apple M1 and M3 systems-on-chip (SoCs): polynomial multiplication, key generation, encapsulation and decapsulation are sped up by <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="0"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c34"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1.54</mn></math></mjx-assistive-mml></mjx-container>–<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="1"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c37"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3.07</mn><mo>×</mo></math></mjx-assistive-mml></mjx-container>, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="2"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c30"></mjx-c><mjx-c class="mjx-c38"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1.08</mn></math></mjx-assistive-mml></mjx-container>–<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="3"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1.33</mn><mo>×</mo></math></mjx-assistive-mml></mjx-container>, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="4"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c31"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1.11</mn></math></mjx-assistive-mml></mjx-container>–<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="5"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c35"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1.50</mn><mo>×</mo></math></mjx-assistive-mml></mjx-container> and <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="6"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c32"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1.20</mn></math></mjx-assistive-mml></mjx-container>–<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="7"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c2E"></mjx-c><mjx-c class="mjx-c39"></mjx-c><mjx-c class="mjx-c38"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-cD7"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1.98</mn><mo>×</mo></math></mjx-assistive-mml></mjx-container>, respectively, over the previous state-of-the-art. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/10">A Prime-Order Group with Complete Formulas from Even-Order Elliptic Curves</a></h5>
      <p><span class="fst-italic">Thomas Pornin</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-10" role="button" aria-expanded="false" aria-controls="abs-10">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/10/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-10" class="collapse abstract"><div><p>This paper describes a generic methodology for obtaining unified, and then complete formulas for a prime-order group abstraction homomorphic to a subgroup of an elliptic curve with even order. The method is applicable to any curve with even order, in finite fields of both even and odd characteristic; it is most efficient on curves with order equal to 2 modulo 4, dubbed "double-odd curves". In large characteristic fields, we obtain doubling formulas with cost as low as 1M + 5S, and the resulting group allows building schemes such as signatures that outperform existing fast solutions, e.g. Ed25519. In binary fields, the obtained formulas are not only complete but also faster than previously known incomplete formulas; we can sign and verify in as low as 18k and 27k cycles on x86 CPUs, respectively. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/11">CCA Security with Short AEAD Tags</a></h5>
      <p><span class="fst-italic">Mustafa Khairallah</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-11" role="button" aria-expanded="false" aria-controls="abs-11">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/11/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-11" class="collapse abstract"><div><p>The size of the authentication tag represents a significant overhead for applications that are limited by bandwidth or memory. Hence, some authenticated encryption designs have a smaller tag than the required privacy level, which was also suggested by the NIST lightweight cryptography standardization project. In the ToSC 2022, two papers have raised questions about the IND-CCA security of AEAD schemes in this situation. These papers show that (a) online AE cannot provide IND-CCA security beyond the tag length, and (b) it is possible to have IND-CCA security beyond the tag length in a restricted Encode-then-Encipher framework. In this paper, we address some of the remaining gaps in this area. Our main result is to show that, for a fixed stretch, Pseudo-Random Injection security implies IND-CCA security as long as the minimum ciphertext size is at least as large as the required IND-CCA security level. We also show that this bound is tight and that any AEAD scheme that allows empty plaintexts with a fixed stretch cannot achieve IND-CCA security beyond the tag length. Next, we look at the weaker notion of MRAE security, and show that two-pass schemes that achieve MRAE security do not achieve IND-CCA security beyond the tag size. This includes SIV and rugged PRPs. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/12">Computing isogenies between   finite Drinfeld modules</a></h5>
      <p><span class="fst-italic">Benjamin Wesolowski</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-12" role="button" aria-expanded="false" aria-controls="abs-12">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/12/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-12" class="collapse abstract"><div><p>We prove that isogenies between Drinfeld F[x]-modules over a finite field can be computed in polynomial time. This breaks Drinfeld analogs of isogeny-based cryptosystems. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/13">Differential-Linear Cryptanalysis of GIFT family and GIFT-based Ciphers</a></h5>
      <p><span class="fst-italic">Shichang Wang, Meicheng Liu, Shiqi Hou, Dongdai Lin</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-13" role="button" aria-expanded="false" aria-controls="abs-13">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/13/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-13" class="collapse abstract"><div><p>At CHES 2017, Banik et al. proposed a lightweight block cipher GIFT consisting of two versions GIFT-64 and GIFT-128. Recently, there are lots of authenticated encryption schemes that adopt GIFT-128 as their underlying primitive, such as GIFT-COFB and HyENA. To promote a comprehensive perception of the soundness of the designs, we evaluate their security against differential-linear cryptanalysis.</p><p>For this, automatic tools have been developed to search differential-linear approximation for the ciphers based on S-boxes. With the assistance of the automatic tools, we find 13-round differential-linear approximations for GIFT-COFB and HyENA. Based on the distinguishers, 18-round key-recovery attacks are given for the message processing phase and initialization phase of both ciphers. Moreover, the resistance of GIFT-64/128 against differential-linear cryptanalysis is also evaluated. The 12-round and 17-round differential-linear approximations are found for GIFT-64 and GIFT-128 respectively, which lead to 18-round and 19-round key-recovery attacks respectively. Here, we stress that our attacks do not threaten the security of these ciphers. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/14">Understanding binary-Goppa decoding</a></h5>
      <p><span class="fst-italic">Daniel J. Bernstein</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-SOK">SoK paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-14" role="button" aria-expanded="false" aria-controls="abs-14">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/14/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-14" class="collapse abstract"><div><p>This paper reviews, from bottom to top, a polynomial-time algorithm to correct <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="8"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi></math></mjx-assistive-mml></mjx-container> errors in classical binary Goppa codes defined by squarefree degree-<mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="9"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D461 TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>t</mi></math></mjx-assistive-mml></mjx-container> polynomials. The proof is factored through a proof of a simple Reed–Solomon decoder, and the algorithm is simpler than Patterson's algorithm. All algorithm layers are expressed as Sage scripts backed by test scripts. All theorems are formally verified. The paper also covers the use of decoding inside the Classic McEliece cryptosystem, including reliable recognition of valid inputs. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/15">Simple Two-Message OT in the Explicit Isogeny Model</a></h5>
      <p><span class="fst-italic">Emmanuela Orsini, Riccardo Zanotto</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-15" role="button" aria-expanded="false" aria-controls="abs-15">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/15/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-15" class="collapse abstract"><div><p>  In this work we study algebraic and generic models for group actions, and extend them to the universal composability (UC) framework of Canetti (FOCS 2001).   We revisit the constructions of Duman et al. (PKC 2023) integrating the type-safe model by Zhandry (Crypto 2022), adapted to the group action setting, and formally define an algebraic action model (AAM). This model restricts the power of the adversary in a similar fashion to the algebraic group model (AGM).   By imposing algebraic behaviour to the adversary and environment of the UC framework, we construct the UC-AAM. Finally, we instantiate UC-AAM with isogeny-based assumptions, in particular the CSIDH action with twists, obtaining the explicit isogeny model, UC-EI; we observe that, under certain assumptions, this model is "closer" to standard UC than the UC-AGM, even though there still exists an important separation.   We demonstrate the utility of our definitions by proving UC-EI security for the passive-secure oblivious transfer protocol described by Lai et al. (Eurocrypt 2021), hence providing the first concretely efficient two-message isogeny-based OT protocol in the random oracle model against malicious adversaries. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/16">Feldman's Verifiable Secret Sharing for a Dishonest Majority</a></h5>
      <p><span class="fst-italic">Yi-Hsiu Chen, Yehuda Lindell</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-16" role="button" aria-expanded="false" aria-controls="abs-16">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/16/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-16" class="collapse abstract"><div><p>Verifiable secret sharing (VSS) protocols enable parties to share secrets while guaranteeing security (in particular, that all parties hold valid and consistent shares) even if the dealer or some of the participants are malicious. Most work on VSS focuses on the honest majority case, primarily since it enables one to guarantee output delivery (e.g., a corrupted recipient cannot prevent an honest dealer from sharing their value). Feldman's VSS is a well known and popular protocol for this task and relies on the discrete log hardness assumption.  In this paper, we present a variant of Feldman's VSS for the dishonest majority setting and formally prove its security. Beyond the basic VSS protocol, we present a publicly-verifiable version, as well as show how to securely add participants to the sharing and how to refresh an existing sharing (all secure in the presence of a dishonest majority). We prove that our protocols are UC secure, for appropriately defined ideal functionalities. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/17">Post-Quantum Ready Key Agreement for Aviation</a></h5>
      <p><span class="fst-italic">Marcel Tiepelt, Christian Martin, Nils Maeurer</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-17" role="button" aria-expanded="false" aria-controls="abs-17">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/17/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-17" class="collapse abstract"><div><p> Transitioning from classically to quantum secure key agreement protocols may require to exchange fundamental components, for example, exchanging Diffie-Hellman-like key exchange with a key encapsulation mechanism (KEM). Accordingly, the corresponding security proof can no longer rely on the Diffie-Hellman assumption, thus invalidating the security guarantees. As a consequence, the security properties have to be re-proven under a KEM-based security notion.</p><p>We initiate the study of the LDACS key agreement protocol (Edition 01.01.00 from 25.04.2023), which is soon-to-be-standardized by the International Civil Aviation Organization. The protocol's cipher suite features Diffie-Hellman as well as a KEM-based key agreement protocol to provide post-quantum security. While the former results in an instantiation of an ISO key agreement inheriting all security properties, the security achieved by the latter is ambiguous. We formalize the computational security using the systematic notions of de Saint Guilhem, Fischlin and Warinshi (CSF '20), and prove the exact security that the KEM-based variant achieves in this model; primarily entity authentication, key secrecy and key authentication. To further strengthen our “pen-and-paper” findings, we model the protocol and its security guarantees using Tamarin, providing an automated proof of the security against a Dolev-Yao attacker. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/18">Broadcast Encryption using Sum-Product decomposition of Boolean functions</a></h5>
      <p><span class="fst-italic">Aurélien Dupin, Simon Abelard</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-18" role="button" aria-expanded="false" aria-controls="abs-18">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/18/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-18" class="collapse abstract"><div><p>    The problem of Broadcast Encryption (BE) consists in broadcasting an encrypted message to a large number of users or receiving devices in such a way that the emitter of the message can control which of the users can or cannot decrypt it.</p><p>    Since the early 1990s, the design of BE schemes has received significant interest and many different concepts were proposed. A major breakthrough was achieved by Naor, Naor and Lotspiech (CRYPTO 2001) by partitioning cleverly the set of authorized users and associating a symmetric key to each subset. Since then, while there have been many advances in public-key based BE schemes, mostly based on bilinear maps, little was made on symmetric cryptography.</p><p>    In this paper, we design a new symmetric-based BE scheme, named <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="10"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-n"><mjx-c class="mjx-c3A3"></mjx-c></mjx-mi><mjx-mi class="mjx-n"><mjx-c class="mjx-c3A0"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">Π</mi></math></mjx-assistive-mml></mjx-container>BE, that relies on logic optimization and consensual security assumptions. It is competitive with the work of Naor et al. and provides a different tradeoff: the bandwidth requirement is significantly lowered at the cost of an increase in the key storage. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/19">How to Make Rational Arguments Practical and Extractable</a></h5>
      <p><span class="fst-italic">Matteo Campanelli, Chaya Ganesh, Rosario Gennaro</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-19" role="button" aria-expanded="false" aria-controls="abs-19">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/19/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-19" class="collapse abstract"><div><p>                We investigate proof systems where security holds against rational parties instead of malicious ones.         Our starting point is the notion of rational arguments, a variant of rational proofs (Azar and Micali, STOC 2012) where security holds against rational adversaries that are also  computationally bounded.</p><p>Rational arguments are an interesting primitive because they generally allow for very efficient protocols, and in particular sublinear verification (i.e. where the Verifier does not have to read the entire input). In this paper we aim at narrowing the gap between  literature on rational schemes and real world applications. Our contribution is two-fold.</p><p>We provide the first construction of rational arguments for the class of polynomial computations that is practical (i.e., it can be applied to real-world computations on reasonably common hardware) and with logarithmic communication. Techniques-wise, we obtain this result through a compiler from information-theoretic protocols and rational proofs for polynomial evaluation. The latter could be of independent interest.</p><p>As a second contribution, we propose a new notion of extractability for rational arguments. Through this notion we can obtain arguments where knowledge of a witness is incentivized (rather than incentivizing mere soundness). We show how our  aforementioned compiler can also be applied to obtain efficient extractable rational arguments for <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="11"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-texatom texclass="ORD"><mjx-mi class="mjx-ss"><mjx-c class="mjx-c1D5AD TEX-SS"></mjx-c><mjx-c class="mjx-c1D5AF TEX-SS"></mjx-c></mjx-mi></mjx-texatom></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow data-mjx-texclass="ORD"><mi mathvariant="sans-serif">NP</mi></mrow></math></mjx-assistive-mml></mjx-container>. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/20">Towards Practical Transciphering for FHE with Setup Independent of the Plaintext Space</a></h5>
      <p><span class="fst-italic">Pierrick Méaux, Jeongeun Park, Hilder V. L. Pereira</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-20" role="button" aria-expanded="false" aria-controls="abs-20">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/20/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-20" class="collapse abstract"><div><p>        Fully Homomorphic Encryption (FHE) is a powerful tool to achieve non-interactive privacy preserving protocols with optimal computation/communication complexity.         However, the main disadvantage is that the actual communication cost (bandwidth) is high due to the large size of FHE ciphertexts.         As a solution,         a technique called transciphering (also known as Hybrid Homomorphic Encryption) was introduced to achieve almost optimal bandwidth for such protocols.          However, all existing works require clients to fix a  precision for the messages or a mathematical structure for the message space beforehand. It results in unwanted constraints          on the plaintext size or underlying structure of FHE based applications.</p><p> In this article, we introduce a new approach for transciphering which does not require fixed message precision decided by the client, for the first time. In more detail, a client uses any kind of FHE-friendly symmetric cipher for <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="12"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mo class="mjx-n"><mjx-c class="mjx-c7B"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="2"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c7D"></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo fence="false" stretchy="false">{</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo fence="false" stretchy="false">}</mo></math></mjx-assistive-mml></mjx-container> to send its input data encrypted bit-by-bit, then the server can choose a precision <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="13"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></mjx-assistive-mml></mjx-container> depending on the application and homomorphically transforms the encrypted bits into FHE ciphertexts encrypting integers in <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="14"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msub><mjx-texatom texclass="ORD"><mjx-mi class="mjx-ds mjx-b"><mjx-c class="mjx-c2124 TEX-A"></mjx-c></mjx-mi></mjx-texatom><mjx-script style="vertical-align: -0.15em;"><mjx-mi class="mjx-i" size="s"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mrow data-mjx-texclass="ORD"><mi mathvariant="double-struck">Z</mi></mrow><mi>p</mi></msub></math></mjx-assistive-mml></mjx-container>. To illustrate our new technique, we evaluate a transciphering using FiLIP cipher and adapt the most practical homomorphic evaluation technique [CCS'22] to keep the practical latency. As a result, our proof-of-concept implementation for <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="15"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45D TEX-I"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>p</mi></math></mjx-assistive-mml></mjx-container> from <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="16"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mn>2</mn></msup></math></mjx-assistive-mml></mjx-container> to <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="17"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-msup><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-script style="vertical-align: 0.363em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c38"></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mn>8</mn></msup></math></mjx-assistive-mml></mjx-container> takes only from <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="18"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c33"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>13</mn></math></mjx-assistive-mml></mjx-container> ms to <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="19"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c33"></mjx-c><mjx-c class="mjx-c37"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>137</mn></math></mjx-assistive-mml></mjx-container> ms. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/21">X-Wing The Hybrid KEM You've Been Looking For</a></h5>
      <p><span class="fst-italic">Manuel Barbosa, Deirdre Connolly, João Diogo Duarte, Aaron Kaiser, Peter Schwabe, Karolin Varner, Bas Westerbaan</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-21" role="button" aria-expanded="false" aria-controls="abs-21">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/21/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-21" class="collapse abstract"><div><p>  X-Wing is a hybrid key-encapsulation mechanism based on X25519 and ML-KEM-768.   It is designed to be the sensible choice for most applications.   The concrete choice of X25519 and ML-KEM-768 allows X-Wing to achieve improved efficiency compared to using a generic KEM combiner.   In this paper, we introduce the X-Wing hybrid KEM construction and provide a proof of security.   We show   (1) that X-Wing is a classically IND-CCA secure KEM if the strong Diffie-Hellman assumption holds in the X25519 nominal group, and   (2) that X-Wing is a post-quantum IND-CCA secure KEM if ML-KEM-768 is itself an IND-CCA secure KEM and SHA3-256 is secure when used as a pseudorandom function.   The first result is proved in the ROM, whereas the second one holds in the standard model.   Loosely speaking, this means X-Wing is secure if either X25519 or ML-KEM-768 is secure.   We stress that these security guarantees and optimizations are only possible due to the concrete choices that were made, and it may not apply in the general case. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/22">New Attacks on LowMC Using Partial Sets in the Single-Data Setting</a></h5>
      <p><span class="fst-italic">Subhadeep Banik, Andrea Caforio, Serge Vaudenay</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-22" role="button" aria-expanded="false" aria-controls="abs-22">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/22/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-22" class="collapse abstract"><div><p> The LowMC family of block ciphers was proposed by Albrecht et al.  in Eurocrypt 2015, specifically targeting adoption in FHE and MPC  applications due to its low multiplicative complexity. The construction  operates a 3-bit quadratic S-box as the sole non-linear transformation in the  algorithm. In contrast, both the linear layer and round key generation are  achieved through multiplications of full rank matrices over GF(2).  The cipher is instantiable using a diverse set of default configurations,  some of which have partial non-linear layers i.e., in which the S-boxes are  not applied over the entire internal state of the cipher.</p><p> The significance of cryptanalysing LowMC was elevated by its inclusion  into the NIST PQC digital signature scheme PICNIC in which  a successful key recovery using a single plaintext/ciphertext pair is akin  to retrieving the secret signing key. The current state-of-the-art  attack in this setting is due to Dinur at Eurocrypt 2021, in which a novel way of  enumerating roots of a Boolean system of equation is  morphed into a key-recovery procedure that undercuts an ordinary  exhaustive search in terms of time complexity for the variants of the cipher up to  five rounds.</p><p> In this work, we demonstrate that this technique can efficiently  be enriched with a specific linearization strategy that reduces  the algebraic degree of the non-linear layer as put forward  by Banik et al. at IACR ToSC 2020(4). This amalgamation yields  new attacks on certain  instances of LowMC up to seven rounds. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/23">A provably masked implementation of BIKE Key Encapsulation Mechanism</a></h5>
      <p><span class="fst-italic">Loïc Demange, Mélissa Rossi</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-23" role="button" aria-expanded="false" aria-controls="abs-23">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/23/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-23" class="collapse abstract"><div><p>BIKE is a post-quantum key encapsulation mechanism (KEM) selected for the 4th round of the NIST's standardization campaign. It relies on the hardness of the syndrome decoding problem for quasi-cyclic codes and on the indistinguishability of the public key from a random element, and provides the most competitive performance among round 4 candidates, which makes it relevant for future real-world use cases. Analyzing its side-channel resistance has been highly encouraged by the community and several works have already outlined various side-channel weaknesses and proposed ad-hoc countermeasures. However, in contrast to the well-documented research line on masking lattice-based algorithms, the possibility of generically protecting code-based algorithms by masking has only been marginally studied in a 2016 paper by Chen et al. in SAC 2015. At this stage of the standardization campaign, it is important to assess the possibility of fully masking BIKE scheme and the resulting cost in terms of performances.</p><p>In this work, we provide the first high-order masked implementation of a code-based algorithm. We had to tackle many issues such as finding proper ways to handle large sparse polynomials, masking the key-generation algorithm or keeping the benefit of the bitslicing. In this paper, we present all the gadgets necessary to provide a fully masked implementation of BIKE, we discuss our different implementation choices and we propose a full proof of masking in the Ishai Sahai and Wagner (Crypto 2003) model.</p><p>More practically, we also provide an open C-code masked implementation of the key-generation, encapsulation and decapsulation algorithms with extensive benchmarks. While the obtained performance is slower than existing masked lattice-based algorithms, we show that masking at order 1, 2, 3, 4 and 5 implies a performance penalty of x5.8, x14.2, x24.4, x38 and x55.6 compared to order 0 (unmasked and unoptimized BIKE). This scaling is encouraging and no Boolean to Arithmetic conversion has been used.</p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/24">Verifiable FHE via Lattice-based SNARKs</a></h5>
      <p><span class="fst-italic">Shahla Atapoor, Karim Baghery, Hilder V. L. Pereira, Jannik Spiessens</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-24" role="button" aria-expanded="false" aria-controls="abs-24">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/24/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-24" class="collapse abstract"><div><p>Fully Homomorphic Encryption (FHE) is a prevalent cryptographic primitive that allows for computation on encrypted data. In various cryptographic protocols, this enables outsourcing computation to a third party while retaining the privacy of the inputs to the computation. However, these schemes make an honest-but-curious assumption about the adversary. Previous work has tried to remove this assumption by combining FHE with Verifiable Computation (VC). Recent work has increased the flexibility of this approach by introducing integrity checks for homomorphic computations over rings. However, efficient FHE for circuits of large multiplicative depth also requires non-ring computations called maintenance operations, i.e. modswitching and keyswitching, which cannot be efficiently verified by existing constructions. We propose the first efficiently verifiable FHE scheme that allows for arbitrary depth homomorphic circuits by utilizing the double-CRT representation in which FHE schemes are typically computed, and using lattice-based SNARKs to prove components of this computation separately, including the maintenance operations. Therefore, our construction can theoretically handle bootstrapping operations. We also present the first implementation of a verifiable computation on encrypted data for a computation that contains multiple ciphertext-ciphertext multiplications. Concretely, we verify the homomorphic computation of an approximate neural network containing three layers and &gt;100 ciphertexts in less than 1 second while maintaining reasonable prover costs. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/25">Simple Three-Round Multiparty Schnorr Signing with Full Simulatability</a></h5>
      <p><span class="fst-italic">Yehuda Lindell</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-25" role="button" aria-expanded="false" aria-controls="abs-25">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/25/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-25" class="collapse abstract"><div><p>In a multiparty signing protocol, also known as a threshold signature scheme, the private signing key is shared amongst a set of parties and only a quorum of those parties can generate a signature. Research on multiparty signing has been growing in popularity recently due to its application to cryptocurrencies. Most work has focused on reducing the number of rounds to two, and as a result: (a) are not fully simulatable in the sense of MPC real/ideal security definitions, and/or (b) are not secure under concurrent composition, and/or (c) utilize non-standard assumptions of different types in their proofs of security. In this paper, we describe a simple three-round multiparty protocol for Schnorr signatures that is secure for any number of corrupted parties; i.e., in the setting of a dishonest majority. The protocol is fully simulatable, secure under concurrent composition, and proven secure in the standard model or random-oracle model (depending on the instantiations of the commitment and zero-knowledge primitives). The protocol realizes an ideal Schnorr signing functionality with perfect security in the ideal commitment and zero-knowledge hybrid model (and thus the only assumptions needed are for realizing these functionalities).</p><p>In our presentation, we do not assume that all parties begin with the message to be signed, the identities of the participating parties and a unique common session identifier, since this is often not the case in practice. Rather, the parties achieve consensus on these parameters as the protocol progresses. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/26">Computing 2-isogenies between Kummer lines</a></h5>
      <p><span class="fst-italic">Damien Robert, Nicolas Sarkis</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-26" role="button" aria-expanded="false" aria-controls="abs-26">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/26/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-26" class="collapse abstract"><div><p>        We use theta groups to study <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="20"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn></math></mjx-assistive-mml></mjx-container>-isogenies between Kummer lines, with a         particular focus on the Montgomery model. This allows us to recover known         formulas, along with more efficient forms for translated isogenies, which         require only <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="21"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D446 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn><mi>S</mi><mo>+</mo><mn>2</mn><msub><mi>m</mi><mn>0</mn></msub></math></mjx-assistive-mml></mjx-container> for evaluation. We leverage these translated isogenies         to build a hybrid ladder for scalar multiplication on Montgomery curves with         rational <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="22"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>2</mn></math></mjx-assistive-mml></mjx-container>-torsion, which cost <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="23"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c33"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D440 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c36"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D446 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>3</mn><mi>M</mi><mo>+</mo><mn>6</mn><mi>S</mi><mo>+</mo><mn>2</mn><msub><mi>m</mi><mn>0</mn></msub></math></mjx-assistive-mml></mjx-container> per bit, compared to <mjx-container class="MathJax CtxtMenu_Attached_0" jax="CHTML" style="font-size: 113.1%; position: relative;" tabindex="0" ctxtmenu_counter="24"><mjx-math class="MJX-TEX" aria-hidden="true"><mjx-mn class="mjx-n"><mjx-c class="mjx-c35"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D440 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c34"></mjx-c></mjx-mn><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D446 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2B"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="3"><mjx-c class="mjx-c31"></mjx-c></mjx-mn><mjx-msub><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D45A TEX-I"></mjx-c></mjx-mi><mjx-script style="vertical-align: -0.15em;"><mjx-mn class="mjx-n" size="s"><mjx-c class="mjx-c30"></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>5</mn><mi>M</mi><mo>+</mo><mn>4</mn><mi>S</mi><mo>+</mo><mn>1</mn><msub><mi>m</mi><mn>0</mn></msub></math></mjx-assistive-mml></mjx-container>         for the standard Montgomery ladder. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/27">On the Two-sided Permutation Inversion Problem</a></h5>
      <p><span class="fst-italic">Gorjan Alagic, Chen Bai, Alexander Poremba, Kaiyan Shi</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-27" role="button" aria-expanded="false" aria-controls="abs-27">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/27/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-27" class="collapse abstract"><div><p>  In the permutation inversion problem, the task is to find the preimage of some challenge value, given oracle access to the permutation. This fundamental problem in query complexity appears in many contexts, particularly cryptography. In this work, we examine the setting in which the oracle allows for quantum queries to both the forward and the inverse direction of the permutation—except that the challenge value cannot be submitted to the latter. Within that setting, we consider three options for the inversion algorithm: whether it can get quantum advice about the permutation, whether the query algorithm can restrict the distribution with which the challenge input is sampled, and whether it must produce the entire preimage (search) or only the first bit (decision). We prove several theorems connecting the hardness of the resulting variations of the permutation inversion problem and establish lower bounds for them. Our results show that, perhaps surprisingly, the permutation inversion problem does not become significantly easier when the adversary is granted oracle access to the inverse—provided it cannot query the challenge itself. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/28">Survey: Recovering cryptographic keys from partial information, by example</a></h5>
      <p><span class="fst-italic">Gabrielle De Micheli, Nadia Heninger</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-SOK">SoK paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-28" role="button" aria-expanded="false" aria-controls="abs-28">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/28/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-28" class="collapse abstract"><div><p>        Side-channel attacks targeting cryptography may leak only partial or indirect information about the secret keys.  There are a variety of techniques in the literature for recovering secret keys from partial information.  In this work, we survey several of the main families of partial key recovery algorithms for RSA, (EC)DSA, and (elliptic curve) Diffie-Hellman, the classical public-key cryptosystems in common use today.  We categorize the known techniques by the structure of the information that is learned by the attacker, and give simplified examples for each technique to illustrate the underlying ideas. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/29">Secure Multi-Party Linear Algebra with Perfect Correctness</a></h5>
      <p><span class="fst-italic">Jules Maire, Damien Vergnaud</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-29" role="button" aria-expanded="false" aria-controls="abs-29">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/29/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-29" class="collapse abstract"><div><p>We present new secure multi-party computation protocols for linear algebra over a finite field, which improve the state-of-the-art in terms of security. We look at the case of unconditional security with perfect correctness, i.e., information-theoretic security without errors. We notably propose an expected constant-round protocol for solving systems of m linear equations in n variables over Fq with expected complexity O(k n^2.5 + k m) (where complexity is measured in terms of the number of secure multiplications required) with k &gt; m(m+n)+1. The previous proposals were not error-free: known protocols can indeed fail and thus reveal information with probability Omega(poly(m)/q). Our protocols are simple and rely on existing computer-algebra techniques, notably the Preparata-Sarwate algorithm, a simple but poorly known “baby-step giant-step” method for computing the characteristic polynomial of a matrix, and techniques due to Mulmuley for error-free linear algebra in positive characteristic. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/30">Preliminary Cryptanalysis   of the Biscuit Signature Scheme</a></h5>
      <p><span class="fst-italic">Charles Bouillaguet, Julia Sauvage</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-30" role="button" aria-expanded="false" aria-controls="abs-30">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/30/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-30" class="collapse abstract"><div><p>    Biscuit is a recent multivariate signature scheme based on the MPC-in-the-Head   paradigm. It has been submitted to the NIST competition for additional   signature schemes. Signatures are derived from a zero-knowledge proof of   knowledge of the solution of a structured polynomial system. This extra   structure enables efficient proofs and compact signatures. This short note   demonstrates that it also makes these polynomial systems easier to solve than   random ones. As a consequence, the original parameters of Biscuit failed to   meet the required security levels and had to be upgraded. </p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/31">New SAT-based Model for Quantum Circuit Decision Problem: Searching for Low-Cost Quantum Implementation</a></h5>
      <p><span class="fst-italic">Jingwen Chen, Qun Liu, Yanhong Fan, Lixuan Wu, Boyun Li, Meiqin Wang</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-31" role="button" aria-expanded="false" aria-controls="abs-31">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/31/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-31" class="collapse abstract"><div><p>In recent years, quantum technology has been rapidly developed. As security analyses for symmetric ciphers continue to emerge, many require an evaluation of the resources needed for the quantum circuit implementation of the encryption algorithm. In this regard, we propose the quantum circuit decision problem, which requires us to determine whether there exists a quantum circuit for a given permutation f using M ancilla qubits and no more than K quantum gates within the circuit depth D. Firstly, we investigate heuristic algorithms and classical SAT-based models in previous works, revealing their limitations in solving the problem. Hence, we innovatively propose an improved SAT-based model incorporating three metrics of quantum circuits. The model enables us to find the optimal quantum circuit of an arbitrary 3 or 4-bit S-box under a given optimization goal based on SAT solvers, which has proved the optimality of circuits constructed by the tool, LIGHTER-R. Then, by combining different criteria in the model, we find more compact quantum circuit implementations of S-boxes such as RECTANGLE and GIFT. For GIFT S-box, our model provides the optimal quantum circuit that only requires 8 gates with a depth of 31. Furthermore, our model can be generalized to linear layers and improve the previous SAT-based model proposed by Huang et al. in ASIACRYPT 2022 by adding the criteria on the number of qubits and the circuit depth.</p></div></div>
    </div>
  
    <div class="mb-5">
      <h5><a href="/p/1/1/32">Towards the Impossibility of Quantum Public Key Encryption with Classical Keys from One-Way Functions</a></h5>
      <p><span class="fst-italic">Samuel Bouaziz–Ermann, Alex B. Grilo, Damien Vergnaud, Quoc-Huy Vu</span>
      </p>
      <div class="d-flex align-items-center mb-3">
        <span class="pubtype-RESEARCH">Research paper</span>
        <a class="mx-4 aopener" data-bs-toggle="collapse" href="#abs-32" role="button" aria-expanded="false" aria-controls="abs-32">Show abstract</a>
        <a class="btn btn-outline-dark" href="/p/1/1/32/pdf"><img alt="PDF" class="icon" src="/images/file-pdf.svg">PDF</a>
      </div>
      <div id="abs-32" class="collapse abstract"><div><p>  There has been a recent interest in proposing quantum protocols whose security   relies on weaker computational assumptions than their classical counterparts.   Importantly to our work, it has been recently shown that public-key encryption   (PKE) from one-way functions (OWF) is possible if we consider quantum public   keys.   Notice that we do not expect classical PKE from OWF given the impossibility   results of Impagliazzo and Rudich (STOC'89).</p><p>  However, the distribution of quantum public keys is a challenging task.   Therefore, the main question that motivates our work is if quantum PKE from   OWF is possible if we have classical public keys.   Such protocols are impossible if ciphertexts are also classical, given the   impossibility result of Austrin et al.(CRYPTO'22) of quantum enhanced   key-agreement (KA) with classical communication.</p><p>   In this paper, we focus on black-box separation for PKE with classical public   key and quantum ciphertext from OWF under the polynomial compatibility   conjecture, first introduced in Austrin et al..   More precisely, we show the separation when the decryption algorithm of the   PKE does not query the OWF.   We prove our result by extending the techniques of Austrin et al.   and we show an attack for KA in an extended classical communication model   where the last message in the protocol can be a quantum state. </p></div></div>
    </div>
  
  </div>
  <div class="col-3">
  </div>
</div>


    </main>
    
    <div class="container-fluid mt-auto" id="pageFooter">
    </div>
    
    <footer class="text-center footer py-3">
      <small>
        <a href="https://iacr.org/copyright.html">Copyright © 2023</a>
        <span class="d-none d-md-inline">by the </span><span class="d-md-none">IACR</span>
        <span class="d-none d-md-inline">International Association for Cryptologic Research</span>
        <span class="d-none d-md-inline">• </span><br class="d-md-none">
        <a href="https://iacr.org/privacy.html">Privacy Policy</a>
      </small>
    </footer>
    
    

<script id="results-template" type="text/x-handlebars-template">
  <div class="p-3 shadow" style="margin-bottom:1rem;max-height:70vh;overflow-y:scroll">
    <p>{{estimated_results}} results (if more than 100, then refine your query)</p>
    <ol>
      {{#each results}}
      <li role="presentation"><a href="{{url}}">{{title}}</a><br>
        {{#each authors }}{{this}}{{#unless @last}}, {{/unless}}{{/each}}</li>
      {{/each}}
    </ol>
  </div>
</script>

<script src="/static/js/handlebars-v4.7.7.js"></script>
<script>
 var theTemplateScript = document.getElementById('results-template').innerHTML;
 var resultsTemplate = Handlebars.compile(theTemplateScript);
 var textinput = document.getElementById('searchbox');

 // Returns a function, that, as long as it continues to be invoked, will not
 // be triggered. The function will be called after it stops being called for
 // N milliseconds. If `immediate` is passed, trigger the function on the
 // leading edge, instead of the trailing.
 function debounce(func, wait, immediate) {
   var timeout;
   return function() {
     var context = this, args = arguments;
     var later = function() {
       timeout = null;
       if (!immediate) func.apply(context, args);
     };
     var callNow = immediate && !timeout;
     clearTimeout(timeout);
     timeout = setTimeout(later, wait);
     if (callNow) func.apply(context, args);
   };
 };
 
 let controller;
 let signal;
 
 var doSearch = debounce(function() {
   
   args = {}
   if (textinput.value) {
     args['q'] = textinput.value;
     if (controller !== undefined) {
       console.log('killing');
       controller.abort();
     }
     controller = new AbortController();
     signal = controller.signal;
     let search_url = "https://cic.iacr.org/api/search" + "?" + new URLSearchParams(args);
     console.log(search_url);
     fetch(search_url, {signal})
       .then((response) => response.json())
       .then((data) => {
         console.log(data);
         let elem = document.getElementById('view');
         if (elem) {elem.innerHTML = '';}
         if (data.results.length > 0) {
           document.getElementById('results').innerHTML = resultsTemplate(data);
         } else {
           document.getElementById('results').innerHTML = '<div class="p-3 shadow">no results</div>';
         }
         controller = undefined;
       }).catch((error) => {
         console.log('error in fetch');
         console.log(error);
       });
   } else {
     console.log('no query');
   }
 }, 500); // only after 250 ms.

 document.querySelectorAll('input').forEach((elem) => {
   elem.addEventListener('input', doSearch);
 });
</script>
  
</body></html>