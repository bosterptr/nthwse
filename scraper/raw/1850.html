<html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" href="/favicon.ico"><link rel="icon" href="/favicon.ico"><meta name="og:title" content="Anshuman Bhartiya"><meta name="description" content="Welcome to Anshuman Bhartiya's blog. Explore articles on information security, technology, and personal insights."><meta name="keywords" content="Anshuman Bhartiya, Information Security, Blog, Technology, Personal Insights, Application Security, Product Security, Cybersecurity, Software Security, Podcast, Public Speaking, Dad, Indian, Immigrant"><meta property="og:title" content="Anshuman Bhartiya"><meta property="og:description" content="Welcome to Anshuman Bhartiya's blog. Explore articles on information security, technology, and personal insights."><meta property="og:image" content="/images/profile.jpg"><meta property="og:url" content="https://anshumanbhartiya.com"><meta name="twitter:card" content="summary_large_image"><script type="application/ld+json">{"@context":"http://schema.org","@type":"WebSite","url":"https://anshumanbhartiya.com","name":"Anshuman Bhartiya","description":"Welcome to Anshuman Bhartiya's blog. Explore articles on information security, technology, and personal insights.","publisher":{"@type":"Person","name":"Anshuman Bhartiya"},"potentialAction":{"@type":"SearchAction","target":"https://anshumanbhartiya.com/search?q={search_term_string}","query-input":"required name=search_term_string"}}</script><title>A Guide On Implementing An Effective SAST Workflow</title><meta name="next-head-count" content="14"><link rel="preload" href="/_next/static/css/bf194d3ad8db832b.css" as="style"><link rel="stylesheet" href="/_next/static/css/bf194d3ad8db832b.css" data-n-g=""><link rel="preload" href="/_next/static/css/6fb705ce96b9a509.css" as="style"><link rel="stylesheet" href="/_next/static/css/6fb705ce96b9a509.css" data-n-p=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/_next/static/chunks/webpack-ee7e63bc15b31913.js" defer=""></script><script src="/_next/static/chunks/framework-9620da855a94eb57.js" defer=""></script><script src="/_next/static/chunks/main-d88229c0f6411e7a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-7ac09ab42e77b1a6.js" defer=""></script><script src="/_next/static/chunks/61-3190c2de40dce773.js" defer=""></script><script src="/_next/static/chunks/799-b13bee71b42d7bca.js" defer=""></script><script src="/_next/static/chunks/745-638c7489ce3d0d60.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-77c1607f5a9134c9.js" defer=""></script><script src="/_next/static/z8-Tu84AGOhucmUVyk7Lx/_buildManifest.js" defer=""></script><script src="/_next/static/z8-Tu84AGOhucmUVyk7Lx/_ssgManifest.js" defer=""></script><link as="script" rel="prefetch" href="/_next/static/chunks/pages/index-b0ccd9d834623068.js"><link as="script" rel="prefetch" href="/_next/static/chunks/pages/technical-blog-69ad22226887783c.js"><link as="script" rel="prefetch" href="/_next/static/chunks/pages/personal-blog-ca2479e032f1ff41.js"><link as="script" rel="prefetch" href="/_next/static/chunks/pages/newsletter-c9cfc12035a98c77.js"><link as="script" rel="prefetch" href="/_next/static/chunks/pages/podcasts-a73eb9841e02aa79.js"></head><body><div id="__next"><div class="layout_container__FUycR"><nav class="Navbar_navbar__GrSXC"><ul class="Navbar_navList__gzP7S"><li class="Navbar_navItem__Fpmiu"><a href="/">Home</a></li><li class="Navbar_navItem__Fpmiu"><a href="/technical-blog">Technical Blog</a></li><li class="Navbar_navItem__Fpmiu"><a href="/personal-blog">Personal Blog</a></li><li class="Navbar_navItem__Fpmiu"><a href="/newsletter">Newsletter</a></li><li class="Navbar_navItem__Fpmiu"><a href="/podcasts">Podcast</a></li><li class="Navbar_navItem__Fpmiu"><a href="/api/rss">RSS</a></li> </ul></nav> <header class="layout_header__SFlEE"></header><main><article><h1 class="utils_headingXl__zlq1q">A Guide On Implementing An Effective SAST Workflow</h1><div class="utils_lightText__B_gv3"><time datetime="2022-08-18">August 18, 2022</time></div><h1>Introduction</h1>
<p>In the previous post, I wrote about <a href="/posts/secure-sdlc">implementing a lightweight Secure SDLC</a> program using the crawl/walk/run approach. In the crawl phase, I covered activities like Rapid Risk Assessments, Tech Design/Architecture Reviews and Threat Modeling that one could implement as a founding Product Security engineer. The 4th piece that I did not cover in that post is implementing a lightweight yet super effective SAST (Static Analysis Security Testing) workflow. So, this post is going to be all things SAST.</p>
<p>Over the span of my AppSec career, I have worked with quite a few SAST tools - IBM AppScan Source, HP Fortify, Brakeman, Bandit and Snyk, to name a few. If we take out the OSS tools from this list, the cost of some of the commercial tools has always been difficult to justify when it comes to running and maintaining a successful SAST program. To be fair, this is mostly applicable to smaller organizations where resourcing and budgeting is always a known constraint. For bigger and more matured organizations that have dedicated teams and budget for SAST, I'd reckon this is not that big of a deal.</p>
<p>Infact, companies like Meta have written their own <a href="https://engineering.fb.com/2019/08/15/security/zoncolan/">SAST</a> tools and have had incredible results from it over the years. This goes to show that just purchasing a SAST tool and implementing in your environment doesn't cut it. It has to be nurtured and cared for with very thoughtful consideration and empathy towards the engineering organization.</p>
<p>As a founding ProdSec engineer, writing your own SAST tool is out of the picture for obvious reasons. Now, let's say you made a strong case to buy an expensive SAST tool and ended up buying it. What happens after that? You are most likely going to put hours of your extremely valuable time triaging the findings and fine-tuning it only to realize that adoption of it across the engineering org is another herculean effort. This will soon turn out to be its own full time job - one that you most likely did not sign up for. I have had this belief for SAST tools for the longest time now until I fell in love with <a href="https://semgrep.dev/">Semgrep</a>.</p>
<p>In a nutshell, If you haven't considered Semgrep as your SAST solution, I'd encourage you to stop reading this post and go take a look at it first. Also, as a disclaimer - this post is neither sponsored nor influenced by the R2C folks so my opinions here are all based on my experiences playing with it. Also, for what it's worth, I am going to walk through how you could achieve your SAST scanning using OSS tools including Semgrep's community tier scan engine and OWASP's Defect Dojo. But, if you really want to have a production grade SAST solution, I'd highly recommend upgrading to the Semgrep Team Tier version. It is totally worth it if you can get the budget approved :). If not, continue reading to find out how you could go about implementing a highly effective SAST solution using just OSS tools and the CI tool of your choice (I am going to use Github Actions for this post). So, let's get started!</p>
<h1>Core Components</h1>
<p>There are 4 core components:</p>
<ul>
<li><strong>Github</strong> as your code repository hosting the code to be scanned as well as your <strong>custom</strong> Semgrep rules</li>
<li><strong>Github Actions</strong> as your CI tool</li>
<li><strong>Semgrep CLI</strong> as your OSS SAST scanner with your custom rules in different modes (comment, monitor and block)</li>
<li><strong>OWASP Defect Dojo</strong> as your OSS vulnerability management tool.</li>
</ul>
<blockquote>
<p>Please note that the Defect Dojo's documentation <a href="https://www.defectdojo.org/">here</a> is pretty good and I won't be covering how to set it up. I am going to assume you already have it up and running and accessible at an endpoint. If you are just trying it out, Docker Compose is probably your best bet to get started and then use something like <a href="https://ngrok.com/">NGROK</a> to grab a HTTPS endpoint. You can then use that endpoint in the Github Action as an environment variable. More on this in the "Setting up Secrets" section. Also, this is exactly what I did for this post.</p>
</blockquote>
<h1>Architecture</h1>
<blockquote>
<p>Please note that the architecture below is an example depicting the ability to run <strong>custom</strong> Semgrep rules - which is where you are going to get the maximum ROI. If you want to run the default rules available in the Semgrep Rules registry, you likely could do it by pulling them down directly from the <code>returntocorp/semgrep-rules</code> repo in the <code>semgrep.yml</code> file. I won't be covering that in this post.</p>
</blockquote>
<p><img src="/images/sast-workflow.png" alt="SAST Workflow"></p>
<p>The above diagram should be self-explanatory but if it's not, below is the jist of the workflow:</p>
<ol>
<li>Awesome developer commits code and issues a Pull Request (PR). Or, code gets pushed directly to the main branch at the specified path.</li>
<li>Github Action gets triggered.</li>
<li>Semgrep rules are downloaded from a Github repo hosting the rules.</li>
</ol>
<blockquote>
<p>If the Github event type is a PR, Semgrep is run against the diff code.</p>
</blockquote>
<blockquote>
<p>If the Github event type is a push to the main branch at the path specified, Semgrep is run against the entire repo.</p>
</blockquote>
<ol start="4">
<li>Findings are sent to Defect Dojo.</li>
<li>A Github Action is triggered based on a cron schedule and code gets downloaded to be scanned.</li>
<li>Semgrep is run against the entire repo and findings are sent to Defect Dojo.</li>
</ol>
<h1>Details</h1>
<h2>Setting up Secrets</h2>
<p>You need some secrets setup in the repository that needs to be scanned. If you would like to run it on multiple repos, you can set these as organization secrets as compared to repository secrets so that you don't have to set it for each repo. These secrets are used/referred in the Semgrep workflow file explained below this section. The secrets are:</p>
<ul>
<li><strong>ACCESS_TOKEN</strong> = Your Personal Access Token to grab the Semgrep rules from your private repo. If you are hosting your rules in a public repo, you likely won't be needing this.</li>
<li><strong>DD_TOKEN</strong> = The API token to send the findings to Defect Dojo. You can grab this from the Defect Dojo UI.</li>
<li><strong>DD_DOMAIN</strong> = The domain where you will be hosting your Defect Dojo instance.</li>
</ul>
<h2>Categories of Semgrep Rules</h2>
<blockquote>
<p>I basically copied the same categories that are available in the <a href="https://semgrep.dev">Semgrep App</a></p>
</blockquote>
<ul>
<li>
<p><strong>Monitor Rules</strong> - These help in identify vulnerabilities that you would like to simply monitor but not comment on the PR or block the PR. These might be the ones that you are trying to get signals on and continue to fine tune them before you want to start commenting/blocking the PR.</p>
</li>
<li>
<p><strong>Comment Rules</strong> - These help in identifying high fidelity vulnerabilities that you would want to leave comments on PR. But, if you are not 100% confident that these will always be True Positives or if there are additional cases that you believe you haven't covered, then it is probably not worth blocking the PR yet.</p>
</li>
<li>
<p><strong>Blocking Rules</strong> - These help in identifying high fidelity vulnerabilities that you are 100% confident will be True Positives and thus the PRs should be blocked, if triggered. Example: you can have a rule to detect hardcoded secret(s) (something that you know for sure shouldn't be in the code) and if triggered, you could block the PR with high confidence.</p>
</li>
</ul>
<h2>Semgrep Workflow File</h2>
<p>We covered the 3 categories of Semgrep rules in the above section. We also covered the 3 scenarios where we would want Semgrep to run in the <code>Architecture</code> section above. You might be wondering - how do we determine what type of rule to run under what scenario? Read below to find out:</p>
<ul>
<li>
<p>For the 2 scenarios where the Github event type is not a PR i.e. when somebody pushes to the main branch at the path specified or when you want the scan to run at a particular schedule, you could run all the 3 categories of rules and report the findings directly to Defect Dojo since the end user/engineer doesn't really see anything and this is more of a scan that happens in the background i.e. there is no feedback loop for the engineers in the CI/CD pipeline.</p>
</li>
<li>
<p>For the scenario when the Github event type is a PR, you would still want to run all the 3 categories of Rules and get the findings reported to Defect Dojo. In addition to that:</p>
<ul>
<li>
<p>For the <strong>monitor</strong> rules, you wouldn't want to leave any comments on the PR, neither block the PR. The command for this is <code>semgrep ci || true</code>. See <a href="https://semgrep.dev/docs/semgrep-ci/configuration-reference/#configuration-options-for-blocking-findings-and-errors">this</a> for more context.</p>
</li>
<li>
<p>For the <strong>comment</strong> rules, you would simply want to leave a comment on the PR but not block the PR. The command for this is also <code>semgrep ci || true</code> like above. However, there are some additional steps of retrieving the results in JSON, parsing it and making it readable on the PR comment and then in the end, leave the comment on the PR.</p>
</li>
<li>
<p>For the <strong>block</strong> rules, you would want to block the PR. The command for this is <code>semgrep ci</code>. Since the step shows as failed on the PR itself, there is no need as such to leave a comment on the PR for this. Folks can directly go to the scan details and see the step that failed and the reason behind it.</p>
</li>
</ul>
</li>
</ul>
<p>All this can be defined in the <code>semgrep.yml</code> file inside the <code>.github/workflows</code> directory of the repository that needs to be scanned. You can grab the file from <a href="https://github.com/anshumanbh/sast-code-repo-poc">this</a> repo. Also, notice that this repo contains all the files to be scanned.</p>
<p>I've tried explaining what each step does at a high level in the diagram below:</p>
<p><img src="/images/semgrep-workflow.png" alt="Semgrep Workflow"></p>
<h2>Semgrep Rules Repo</h2>
<p>If you see the architecture above, you will notice that the Github Actions workflow downloads the Semgrep rules from a different repo. You can think of this like your central repo where you can manage all your Semgrep rules in different modes (<code>monitor</code>, <code>comment</code> and <code>block</code>). There is also a <code>scripts</code> directory which contains glue scripts like - sending results from the Github Action to Defect Dojo or to parse the JSON output from Semgrep and make it readable to be displayed as a comment on the PR. You can take a look at how this repo should be structured by navigating <a href="https://github.com/anshumanbh/semgrep-rules-poc">here</a>.</p>
<h1>Walkthroughs</h1>
<h2>Scenario # 1 - Push to the main branch</h2>
<iframe id="ytplayer" type="text/html" width="640" height="360" src="https://www.youtube.com/embed/b_4uW3cZ2uM" frameborder="0" allowfullscreen=""></iframe>
<h2>Scenario # 2 - Run on a schedule</h2>
<p>The scan steps that run in Scenario # 2 are literally the same as Scenario # 1 above. The only difference is that in this case, the workflow itself gets triggered based on a cron schedule (specified <a href="https://github.com/anshumanbh/sast-code-repo-poc/blob/main/.github/workflows/semgrep.yml#L9">here</a>) as compared to a push to the main branch (like in Scenario # 1 above). Also, when you navigate to the <strong>Actions</strong> tab in your repo, you should be seeing something like below (See the highlighted red section that shows that the action ran on a schedule):</p>
<p><img src="/images/semgrep-scheduled.png" alt="Semgrep Scheduled"></p>
<h2>Scenario # 3 - When a PR is issued</h2>
<blockquote>
<p>This is probably the most impactful scenario that you can implement in driving an effective SAST workflow. This is because the feedback loop for engineers is instantaneous using custom rules (across varying languages) with the flexibility of simply monitoring, leaving a comment or blocking the PR.</p>
</blockquote>
<iframe id="ytplayer" type="text/html" width="640" height="360" src="https://www.youtube.com/embed/deFtKVvDjJU" frameborder="0" allowfullscreen=""></iframe>
<hr>
<p>That's it for this post folks! In this post, I covered some basic examples wrt SAST rules because the focus was more on the workflow, not so much on the type of rules. In the next post, I plan to cover some custom rules that could be written to identify things such as Authorization vulnerabilities. Stay tuned!</p></article></main><div class="layout_newsletter__AhJ0W"><form><div>If you like the content and don't want to miss out on new posts, enter your
          email and hit the Subscribe button below. I promise I won't spam. Only premium content!</div><label for="email-input">Email: </label><input id="email-input" name="email" placeholder="you@awesome.com" required="" type="email"><button type="submit">Subscribe</button></form></div><div class="layout_backToHome__D9QFr"><a href="/">← Back to home</a></div><div class="layout_footer__WlhMu"></div><div class="layout_social__79Yte"><a href="https://github.com/anshumanbh"><img loading="lazy" width="30" height="30" decoding="async" data-nimg="1" style="color:transparent" srcset="/_next/image?url=%2Fimages%2Fgithub.png&amp;w=32&amp;q=75 1x, /_next/image?url=%2Fimages%2Fgithub.png&amp;w=64&amp;q=75 2x" src="/_next/image?url=%2Fimages%2Fgithub.png&amp;w=64&amp;q=75"></a><a href="https://twitter.com/anshuman_bh"><img loading="lazy" width="30" height="30" decoding="async" data-nimg="1" style="color:transparent" srcset="/_next/image?url=%2Fimages%2Ftwitter.png&amp;w=32&amp;q=75 1x, /_next/image?url=%2Fimages%2Ftwitter.png&amp;w=64&amp;q=75 2x" src="/_next/image?url=%2Fimages%2Ftwitter.png&amp;w=64&amp;q=75"></a><a href="https://www.linkedin.com/in/anshumanbhartiya/"><img loading="lazy" width="30" height="30" decoding="async" data-nimg="1" style="color:transparent" srcset="/_next/image?url=%2Fimages%2Flinkedin.jpeg&amp;w=32&amp;q=75 1x, /_next/image?url=%2Fimages%2Flinkedin.jpeg&amp;w=64&amp;q=75 2x" src="/_next/image?url=%2Fimages%2Flinkedin.jpeg&amp;w=64&amp;q=75"></a><a href="https://instagram.com/abhartiy"><img loading="lazy" width="30" height="30" decoding="async" data-nimg="1" style="color:transparent" srcset="/_next/image?url=%2Fimages%2Finstagram.jpeg&amp;w=32&amp;q=75 1x, /_next/image?url=%2Fimages%2Finstagram.jpeg&amp;w=64&amp;q=75 2x" src="/_next/image?url=%2Fimages%2Finstagram.jpeg&amp;w=64&amp;q=75"></a><a href="https://hackerone.com/anshuman_bh"><img loading="lazy" width="30" height="25" decoding="async" data-nimg="1" style="color:transparent" srcset="/_next/image?url=%2Fimages%2Fhackerone.png&amp;w=32&amp;q=75 1x, /_next/image?url=%2Fimages%2Fhackerone.png&amp;w=64&amp;q=75 2x" src="/_next/image?url=%2Fimages%2Fhackerone.png&amp;w=64&amp;q=75"></a><a href="https://bugcrowd.com/anshuman_bh"><img loading="lazy" width="30" height="25" decoding="async" data-nimg="1" style="color:transparent" src="/images/bugcrowd.svg"></a></div><div class="layout_copyright__yuDki">AB © 2022</div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"sast-workflow","markdown":"\n# Introduction\n\nIn the previous post, I wrote about [implementing a lightweight Secure SDLC](/posts/secure-sdlc) program using the crawl/walk/run approach. In the crawl phase, I covered activities like Rapid Risk Assessments, Tech Design/Architecture Reviews and Threat Modeling that one could implement as a founding Product Security engineer. The 4th piece that I did not cover in that post is implementing a lightweight yet super effective SAST (Static Analysis Security Testing) workflow. So, this post is going to be all things SAST.\n\nOver the span of my AppSec career, I have worked with quite a few SAST tools - IBM AppScan Source, HP Fortify, Brakeman, Bandit and Snyk, to name a few. If we take out the OSS tools from this list, the cost of some of the commercial tools has always been difficult to justify when it comes to running and maintaining a successful SAST program. To be fair, this is mostly applicable to smaller organizations where resourcing and budgeting is always a known constraint. For bigger and more matured organizations that have dedicated teams and budget for SAST, I'd reckon this is not that big of a deal.\n\nInfact, companies like Meta have written their own [SAST](https://engineering.fb.com/2019/08/15/security/zoncolan/) tools and have had incredible results from it over the years. This goes to show that just purchasing a SAST tool and implementing in your environment doesn't cut it. It has to be nurtured and cared for with very thoughtful consideration and empathy towards the engineering organization.\n\nAs a founding ProdSec engineer, writing your own SAST tool is out of the picture for obvious reasons. Now, let's say you made a strong case to buy an expensive SAST tool and ended up buying it. What happens after that? You are most likely going to put hours of your extremely valuable time triaging the findings and fine-tuning it only to realize that adoption of it across the engineering org is another herculean effort. This will soon turn out to be its own full time job - one that you most likely did not sign up for. I have had this belief for SAST tools for the longest time now until I fell in love with [Semgrep](https://semgrep.dev/).\n\nIn a nutshell, If you haven't considered Semgrep as your SAST solution, I'd encourage you to stop reading this post and go take a look at it first. Also, as a disclaimer - this post is neither sponsored nor influenced by the R2C folks so my opinions here are all based on my experiences playing with it. Also, for what it's worth, I am going to walk through how you could achieve your SAST scanning using OSS tools including Semgrep's community tier scan engine and OWASP's Defect Dojo. But, if you really want to have a production grade SAST solution, I'd highly recommend upgrading to the Semgrep Team Tier version. It is totally worth it if you can get the budget approved :). If not, continue reading to find out how you could go about implementing a highly effective SAST solution using just OSS tools and the CI tool of your choice (I am going to use Github Actions for this post). So, let's get started!\n\n# Core Components\n\nThere are 4 core components:\n\n- **Github** as your code repository hosting the code to be scanned as well as your **custom** Semgrep rules\n- **Github Actions** as your CI tool\n- **Semgrep CLI** as your OSS SAST scanner with your custom rules in different modes (comment, monitor and block)\n- **OWASP Defect Dojo** as your OSS vulnerability management tool.\n\n\u003e Please note that the Defect Dojo's documentation [here](https://www.defectdojo.org/) is pretty good and I won't be covering how to set it up. I am going to assume you already have it up and running and accessible at an endpoint. If you are just trying it out, Docker Compose is probably your best bet to get started and then use something like [NGROK](https://ngrok.com/) to grab a HTTPS endpoint. You can then use that endpoint in the Github Action as an environment variable. More on this in the \"Setting up Secrets\" section. Also, this is exactly what I did for this post.\n\n# Architecture\n\n\u003e Please note that the architecture below is an example depicting the ability to run **custom** Semgrep rules - which is where you are going to get the maximum ROI. If you want to run the default rules available in the Semgrep Rules registry, you likely could do it by pulling them down directly from the `returntocorp/semgrep-rules` repo in the `semgrep.yml` file. I won't be covering that in this post.\n\n![SAST Workflow](/images/sast-workflow.png)\n\nThe above diagram should be self-explanatory but if it's not, below is the jist of the workflow:\n\n1. Awesome developer commits code and issues a Pull Request (PR). Or, code gets pushed directly to the main branch at the specified path.\n2. Github Action gets triggered.\n3. Semgrep rules are downloaded from a Github repo hosting the rules.\n\n\u003e If the Github event type is a PR, Semgrep is run against the diff code.\n\n\u003e If the Github event type is a push to the main branch at the path specified, Semgrep is run against the entire repo.\n\n4. Findings are sent to Defect Dojo.\n5. A Github Action is triggered based on a cron schedule and code gets downloaded to be scanned.\n6. Semgrep is run against the entire repo and findings are sent to Defect Dojo.\n\n# Details\n\n## Setting up Secrets\n\nYou need some secrets setup in the repository that needs to be scanned. If you would like to run it on multiple repos, you can set these as organization secrets as compared to repository secrets so that you don't have to set it for each repo. These secrets are used/referred in the Semgrep workflow file explained below this section. The secrets are:\n\n- **ACCESS_TOKEN** = Your Personal Access Token to grab the Semgrep rules from your private repo. If you are hosting your rules in a public repo, you likely won't be needing this.\n- **DD_TOKEN** = The API token to send the findings to Defect Dojo. You can grab this from the Defect Dojo UI.\n- **DD_DOMAIN** = The domain where you will be hosting your Defect Dojo instance.\n\n## Categories of Semgrep Rules\n\n\u003e I basically copied the same categories that are available in the [Semgrep App](https://semgrep.dev)\n\n- **Monitor Rules** - These help in identify vulnerabilities that you would like to simply monitor but not comment on the PR or block the PR. These might be the ones that you are trying to get signals on and continue to fine tune them before you want to start commenting/blocking the PR.\n\n- **Comment Rules** - These help in identifying high fidelity vulnerabilities that you would want to leave comments on PR. But, if you are not 100% confident that these will always be True Positives or if there are additional cases that you believe you haven't covered, then it is probably not worth blocking the PR yet.\n\n- **Blocking Rules** - These help in identifying high fidelity vulnerabilities that you are 100% confident will be True Positives and thus the PRs should be blocked, if triggered. Example: you can have a rule to detect hardcoded secret(s) (something that you know for sure shouldn't be in the code) and if triggered, you could block the PR with high confidence.\n\n## Semgrep Workflow File\n\nWe covered the 3 categories of Semgrep rules in the above section. We also covered the 3 scenarios where we would want Semgrep to run in the `Architecture` section above. You might be wondering - how do we determine what type of rule to run under what scenario? Read below to find out:\n\n- For the 2 scenarios where the Github event type is not a PR i.e. when somebody pushes to the main branch at the path specified or when you want the scan to run at a particular schedule, you could run all the 3 categories of rules and report the findings directly to Defect Dojo since the end user/engineer doesn't really see anything and this is more of a scan that happens in the background i.e. there is no feedback loop for the engineers in the CI/CD pipeline.\n\n- For the scenario when the Github event type is a PR, you would still want to run all the 3 categories of Rules and get the findings reported to Defect Dojo. In addition to that:\n\n  - For the **monitor** rules, you wouldn't want to leave any comments on the PR, neither block the PR. The command for this is `semgrep ci || true`. See [this](https://semgrep.dev/docs/semgrep-ci/configuration-reference/#configuration-options-for-blocking-findings-and-errors) for more context.\n\n  - For the **comment** rules, you would simply want to leave a comment on the PR but not block the PR. The command for this is also `semgrep ci || true` like above. However, there are some additional steps of retrieving the results in JSON, parsing it and making it readable on the PR comment and then in the end, leave the comment on the PR.\n\n  - For the **block** rules, you would want to block the PR. The command for this is `semgrep ci`. Since the step shows as failed on the PR itself, there is no need as such to leave a comment on the PR for this. Folks can directly go to the scan details and see the step that failed and the reason behind it.\n\nAll this can be defined in the `semgrep.yml` file inside the `.github/workflows` directory of the repository that needs to be scanned. You can grab the file from [this](https://github.com/anshumanbh/sast-code-repo-poc) repo. Also, notice that this repo contains all the files to be scanned.\n\nI've tried explaining what each step does at a high level in the diagram below:\n\n![Semgrep Workflow](/images/semgrep-workflow.png)\n\n## Semgrep Rules Repo\n\nIf you see the architecture above, you will notice that the Github Actions workflow downloads the Semgrep rules from a different repo. You can think of this like your central repo where you can manage all your Semgrep rules in different modes (`monitor`, `comment` and `block`). There is also a `scripts` directory which contains glue scripts like - sending results from the Github Action to Defect Dojo or to parse the JSON output from Semgrep and make it readable to be displayed as a comment on the PR. You can take a look at how this repo should be structured by navigating [here](https://github.com/anshumanbh/semgrep-rules-poc).\n\n# Walkthroughs\n\n## Scenario # 1 - Push to the main branch\n\n\u003ciframe id=\"ytplayer\" type=\"text/html\" width=\"640\" height=\"360\"\n  src=\"https://www.youtube.com/embed/b_4uW3cZ2uM\"\n  frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\n\n## Scenario # 2 - Run on a schedule\n\nThe scan steps that run in Scenario # 2 are literally the same as Scenario # 1 above. The only difference is that in this case, the workflow itself gets triggered based on a cron schedule (specified [here](https://github.com/anshumanbh/sast-code-repo-poc/blob/main/.github/workflows/semgrep.yml#L9)) as compared to a push to the main branch (like in Scenario # 1 above). Also, when you navigate to the **Actions** tab in your repo, you should be seeing something like below (See the highlighted red section that shows that the action ran on a schedule):\n\n![Semgrep Scheduled](/images/semgrep-scheduled.png)\n\n## Scenario # 3 - When a PR is issued\n\n\u003e This is probably the most impactful scenario that you can implement in driving an effective SAST workflow. This is because the feedback loop for engineers is instantaneous using custom rules (across varying languages) with the flexibility of simply monitoring, leaving a comment or blocking the PR.\n\n\u003ciframe id=\"ytplayer\" type=\"text/html\" width=\"640\" height=\"360\"\n  src=\"https://www.youtube.com/embed/deFtKVvDjJU\"\n  frameborder=\"0\" allowfullscreen\u003e\u003c/iframe\u003e\n\n---\n\nThat's it for this post folks! In this post, I covered some basic examples wrt SAST rules because the focus was more on the workflow, not so much on the type of rules. In the next post, I plan to cover some custom rules that could be written to identify things such as Authorization vulnerabilities. Stay tuned!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","title":"A Guide On Implementing An Effective SAST Workflow","date":"2022-08-18","type":"technical"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"sast-workflow"},"buildId":"z8-Tu84AGOhucmUVyk7Lx","isFallback":false,"gsp":true,"scriptLoader":[]}</script><next-route-announcer><p aria-live="assertive" id="__next-route-announcer__" role="alert" style="border: 0px; clip: rect(0px, 0px, 0px, 0px); height: 1px; margin: -1px; overflow: hidden; padding: 0px; position: absolute; top: 0px; width: 1px; white-space: nowrap; overflow-wrap: normal;"></p></next-route-announcer><script src="/_next/static/chunks/pages/technical-blog-69ad22226887783c.js"></script><script src="/_next/static/chunks/pages/index-b0ccd9d834623068.js"></script></body></html>