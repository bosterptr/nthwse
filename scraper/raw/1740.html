<html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Obfuscating native code for fun: Part 1 - Introduction - es3n1n's Blog</title><link rel="icon" type="image/png" href="/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1">
<meta property="og:title" content="Obfuscating native code for fun: Part 1 - Introduction"><meta property="og:description" content="In this series of posts, I will try to cover all the common knowledge you would need to create your PE bin2bin obfuscator. This year I saw a rise of interest in the topics of software obfuscation and deobfuscation, yet I didn’t see any new open-source projects popping up in public, maybe this series of posts could fix that."><meta property="og:type" content="article"><meta property="og:url" content="http://blog.es3n1n.eu/posts/obfuscator-pt-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-06T00:00:00+00:00"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Obfuscating native code for fun: Part 1 - Introduction"><meta name="twitter:description" content="In this series of posts, I will try to cover all the common knowledge you would need to create your PE bin2bin obfuscator. This year I saw a rise of interest in the topics of software obfuscation and deobfuscation, yet I didn’t see any new open-source projects popping up in public, maybe this series of posts could fix that."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet"><link rel="stylesheet" type="text/css" media="screen" href="https://blog.es3n1n.eu/css/normalize.css"><link rel="stylesheet" type="text/css" media="screen" href="https://blog.es3n1n.eu/css/main.css"><link rel="stylesheet" type="text/css" href="https://blog.es3n1n.eu/css/patches.css"><link rel="stylesheet" type="text/css" href="https://blog.es3n1n.eu/css/dark.css"><link rel="stylesheet" type="text/css" href="https://blog.es3n1n.eu/css/dark_patches.css"><script src="https://blog.es3n1n.eu/js/feather.min.js"></script><script src="https://blog.es3n1n.eu/js/main.js"></script></head><body><div class="container wrapper post"><div class="header"><base href="https://blog.es3n1n.eu/"><h1 class="site-title"><a href="https://blog.es3n1n.eu/">es3n1n's Blog</a></h1><div class="site-description"><h2>Reverse engineering, programming and some other boring stuff.</h2><nav class="nav social"><ul class="flat"><a href="https://twitter.com/es3n1n" title="Twitter"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-twitter"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg></a><a href="https://github.com/es3n1n" title="GitHub"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg></a></ul></nav></div><nav class="nav"><ul class="flat"><li><a href="/">Home</a></li><li><a href="/posts">All Posts</a></li><li><a href="/tags">Tags</a></li><li><a href="/about">About</a></li></ul></nav></div><div class="post-header"><h1 class="title">Obfuscating native code for fun: Part 1 - Introduction</h1><div class="meta">Posted at — Dec 6, 2023</div></div><div class="markdown"><p>In this series of posts, I will try to cover all the common knowledge you would need to create your <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> <a href="/posts/obfuscator-pt-1/#acronyms">bin2bin</a> obfuscator. This year I saw a rise of interest in the topics of software obfuscation and deobfuscation, yet I didn’t see any new open-source projects popping up in public, maybe this series of posts could fix that.</p><p>Please note, that all the common things I will talk about here could be applied for the deobfuscation too, but I will mostly focus on the obfuscation.</p><p>This is the first part of this series <em>(and hopefully it won’t be the last)</em> where I will cover the common info about obfuscators and will write my own obfuscator that could be a good base for a <a href="/posts/obfuscator-pt-1/#acronyms">bin2bin</a> obfuscator.</p><h1 id="preface">Preface</h1><p>There are already quite a lot of open-source native code protectors such as <a href="https://github.com/weak1337/Alcatraz">Alcatraz</a> and <a href="https://github.com/mike1k/perses">Perses</a>. However, none of these solutions could be applied as a good base for learners and scaling such projects could be a massive problem, that’s why I decided to do my own thing and maybe it will be way more understandable for the new developers in this niche.</p><p>Please also note that while this article is about obfuscation topics, this wasn’t meant for already experienced people in this field. Although all of this is pretty obvious, someone had to explain this to everyone.</p><p>The source code of this project can be located on my <a href="https://github.com/es3n1n/obfuscator">GitHub</a>.</p><h1 id="abstract-info">Abstract info</h1><h2 id="who-needs-this">Who needs this?</h2><p>A reader with no prior knowledge in this field can pose such a question, the answer is simple if we take into account all the <a href="/posts/obfuscator-pt-1/#acronyms">reverse-engineers</a> that will try to crack your software, would it be a game, an extension for Word or anything else. Generally, obfuscation is applied when you don’t want anybody else to understand how your app works internally.</p><h2 id="software-obfuscator-types">Software obfuscator types</h2><p>There are two types of software obfuscators.</p><h3 id="binary-to-binary">Binary to binary</h3><p>Or <a href="/posts/obfuscator-pt-1/#acronyms">bin2bin</a> for short. As soon as you compile your application with a compiler, on the output you receive a binary, whether it’s an <a href="/posts/obfuscator-pt-1/#acronyms">ELF</a>, <a href="/posts/obfuscator-pt-1/#acronyms">PE</a>, or any other file. And then, when you need to obfuscate this app you “feed” the obfuscator this binary with additional debug information (<a href="/posts/obfuscator-pt-1/#acronyms">MAP</a>, <a href="/posts/obfuscator-pt-1/#acronyms">PDB</a>, etc). The obfuscator then does some magic with the binary and on the output, it gives you the obfuscated version of this binary.</p><p>A good example of such code protectors could be <a href="https://vmpsoft.com/">VMProtect</a> and <a href="https://oreans.com/">Themida</a>.</p><p><img src="/posts/obfuscator-pt-1/diags/bin2bin.png" alt="bin2bin_diag"></p><h3 id="linker-level">Linker level</h3><p>An obfuscator that operates at the linker level is most likely an obfuscator that will have <strong>way</strong> more info about the execution of this code, because of the way how they’re implemented.</p><p>It is pretty common to create an <a href="https://github.com/llvm/llvm-project">LLVM</a> fork and directly modify the LLVM transforms, so that as soon as your function is compiled, but not linked, you can apply the obfuscation.</p><p>A good example of such a code protector could be <a href="https://github.com/obfuscator-llvm/obfuscator">OLLVM</a>.</p><p><img src="/posts/obfuscator-pt-1/diags/linkerlevel.png" alt="linker_level"></p><h2 id="portable-executable">Portable executable</h2><p>To implement a <a href="/posts/obfuscator-pt-1/#acronyms">bin2bin</a> obfuscator you need to first have a deep understanding of how the executable format works (<a href="/posts/obfuscator-pt-1/#acronyms">PE</a> in our case).</p><p>Here is a brief overview of the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> file format</p><h3 id="architecture">Architecture</h3><p>There are five architectures that <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> supports, but we’ll cover only two of them, which are the common ones.</p><table><thead><tr><th>Architecture</th><th>Supported by obfuscator</th></tr></thead><tbody><tr><td><a href="https://en.wikipedia.org/wiki/X86-32">x86_32</a> (x86)</td><td>Yes</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/X86-64">x86_64</a> (x64)</td><td>Yes</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/IA-64">ia64</a></td><td>No</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/ARM_architecture">arm</a></td><td>No</td></tr><tr><td><a href="https://en.wikipedia.org/wiki/ARM64">arm64</a></td><td>No</td></tr></tbody></table><h3 id="sections">Sections</h3><p>Essentially, the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> file is split into “sections”, which store the raw bytes of data and its protection(for example you can’t just write into the section with code, because its protection allows you only READ/EXECUTE operations).</p><p>Typically there are 3 sections in the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> binary that we need to process</p><table><thead><tr><th>Name</th><th>Contains</th><th>Protection</th></tr></thead><tbody><tr><td><code>.text</code></td><td>Code</td><td>Read, execute</td></tr><tr><td><code>.data</code></td><td>Global data</td><td>Read, write</td></tr><tr><td><code>.rdata</code></td><td>Readonly data</td><td>Read</td></tr></tbody></table><h3 id="relocations">Relocations</h3><p>As you may have heard, the operation system could run the code with <a href="/posts/obfuscator-pt-1/#acronyms">ASLR</a> to protect the app from some vulnerabilities. Thus, the application that references for example some global vars from the <code>.data</code> section should always <a href="/posts/obfuscator-pt-1/#acronyms">dereference</a> the right address for this var.</p><p>Relocations in <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> are implemented in a way where your code references a pointer to the data with its base set to the default one (which is, stored in the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> header).</p><p>Then, as soon as your image gets loaded to the memory, the part of OS that loads your <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> images iterates through all the references to the data that it should relocate and changes the base of this reference.</p><p>For example, when you reference</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span>, <span style="color:#e06c75">dword</span> <span style="color:#e06c75">ptr</span> [<span style="color:#d19a66">0x1400000017</span>]
</span></span></code></pre></div><p>with the default image base set to <code>0x1400000000</code>, the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> then allocates the image for example at <code>0x1600000000</code> and relocates the pointer to</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span>, <span style="color:#e06c75">dword</span> <span style="color:#e06c75">ptr</span> [<span style="color:#d19a66">0x1600000017</span>]
</span></span></code></pre></div><p>To do that, the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> stores a relocation table inside of it with all the references, that the OS should process.</p><p>However, in x64 applications, the more common way compilers are placing references, instead of such relocations is <a href="/posts/obfuscator-pt-1/#acronyms">RIP</a> addressing. It means that instead of placing a direct address to this symbol, it would rather calculate a difference between the current instruction address and the symbol that it needs to reference, and will use this offset. So that you don’t even need to relocate anything!</p><p>For example, this is how you would reference an <code>0x13371337</code> address:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span>1336<span style="color:#e06c75">fff9:</span> <span style="color:#61afef;font-weight:700">lea</span> <span style="color:#e06c75">rax</span>, [<span style="color:#e06c75">rip</span> + <span style="color:#d19a66">0x1337</span>]
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">; value of rax = 0x1336fff9 + 7 (instruction size) + 0x1337 = 0x13371337
</span></span></span></code></pre></div><h3 id="imports">Imports</h3><p>When you reference for example a <a href="/posts/obfuscator-pt-1/#acronyms">WinAPI</a> function <code>Sleep</code>, the compiler does not statically link the implementation of this function within your app, rather it marks in <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> that there’s this <code>Sleep</code> function, which is an imported function from <code>user32.dll</code>. When the OS loads this file, it also loads the <code>user32.dll</code> to the memory and updates the address of the <code>Sleep</code> function and our code can reference it.</p><h1 id="implementation">Implementation</h1><p>The implementation of my obfuscator is written in C++ 23 and I chose these dependencies:</p><ul><li><a href="https://github.com/zyantific/zasm">zasm</a>: An asmjit-like wrapper for the <code>Zydis</code>.</li><li><a href="https://github.com/can1357/linux-pe">linux-pe</a>: A <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> file format parser.</li></ul><p>These dependencies are the only ones that you need to implement all the needed stuff, but to make the development process a bit easier I also added two more libraries:</p><ul><li><a href="https://github.com/Neargye/magic_enum">magic_enum</a>: A library that adds easier conversions from enum values to their names.</li><li><a href="https://github.com/google/googletest">GTest</a>: A test framework written by Google.</li></ul><p>As for the build system, I chose the <a href="https://cmake.org">CMake</a> with <a href="https://github.com/build-cpp/cmkr">cmkr</a> because I also wanted my obfuscator to cross-compile to any architecture and system.</p><p>For the static code analysis, I used the <a href="https://clang.llvm.org/docs/ClangFormat.html">clang-format</a> and <a href="https://clang.llvm.org/extra/clang-tidy/">clang-tidy</a>.</p><p>While developing the code analysis and transforms I also implemented a couple of scripts in Python with <a href="https://github.com/Z3Prover/z3">z3</a> and <a href="https://graphviz.org">graphviz</a>.</p><p><img src="/posts/obfuscator-pt-1/diags/obfuscator.png" alt="obf_diag"></p><h2 id="pe-loader">PE Loader</h2><p>This is so far the easiest part, because of how easy it is to use <code>linux-pe</code>.</p><p>All I had to do was to implement a file read function and just cast the file start to <code>win::image_t</code>, on top of that, I created a custom wrapper and implemented:</p><ul><li>Architecture check</li><li><a href="/posts/obfuscator-pt-1/#acronyms">PE</a> magic constants checks</li><li>Section parser (+ search)</li><li>Relocations parser (+ editor)</li><li>Codeview70 search (PDB info)</li><li>Section Editor</li><li>Directory parser</li><li>Rebuilder (I will talk about it a bit more later)</li></ul><p>All of these are pretty straightforward to implement, if you know what are you doing and I don’t want to go into details about it (for now, at least). In any case, if you’re interested in how I implemented it, you can always check out the <a href="https://github.com/es3n1n/obfuscator">source code</a>.</p><h2 id="function-parser">Function parser</h2><p>Or <code>func_parser</code>, is the module that parses function start/end <a href="/posts/obfuscator-pt-1/#acronyms">RVAs</a> from various sources, for now only <a href="/posts/obfuscator-pt-1/#acronyms">MAP</a> and <a href="/posts/obfuscator-pt-1/#acronyms">PDB</a> files are supported. The only thing that my function parsers lack is the <a href="/posts/obfuscator-pt-1/#acronyms">name demangler</a>.</p><p><img src="/posts/obfuscator-pt-1/diags/funcparser.png" alt="funcparser"></p><h3 id="pdb">PDB</h3><p><a href="/posts/obfuscator-pt-1/#acronyms">PDB</a> is the program database format that contains a lot of stuff, somehow this file format is a bit obscure, even though it is pretty common. While I was developing my implementation of the <a href="/posts/obfuscator-pt-1/#acronyms">PDB</a> parser I referenced the <a href="https://llvm.org/docs/PDB/index.html">LLVM Documentation</a> and <a href="https://github.com/MolecularMatters/raw_pdb">raw_pdb</a> project.</p><p>There are two versions of <a href="/posts/obfuscator-pt-1/#acronyms">PDB</a> files, version 2 and version 7. The most common one in 2023 is version 7 and this is the only version that my <a href="/posts/obfuscator-pt-1/#acronyms">PDB</a> parser supports.</p><h3 id="map">MAP</h3><p>There are two versions of <a href="/posts/obfuscator-pt-1/#acronyms">MAP</a> files, <a href="/posts/obfuscator-pt-1/#acronyms">MSVC</a> version and <a href="/posts/obfuscator-pt-1/#acronyms">GCC</a> version. My parser supports only the <a href="/posts/obfuscator-pt-1/#acronyms">MSVC</a> version. However, implementing a parser for <a href="/posts/obfuscator-pt-1/#acronyms">GCC</a> version is fairly straightforward. If I have time before publishing this article, I will add it.</p><h2 id="disassembling">Disassembling</h2><p>The library I am using(<a href="https://github.com/zyantific/zasm">zasm</a>) supports the <a href="/posts/obfuscator-pt-1/#acronyms">disassembling</a> of the x86 code to a single container(<code>zasm::Program</code>), and then <a href="/posts/obfuscator-pt-1/#acronyms">assembling</a> instructions from this container back. And to do that I implemented my wrapper for a wrapper. Its name is <code>EbinAsm</code>, <code>easm</code> in short form.</p><p>EbinAsm’s purpose is to simplify the usage of the <a href="https://github.com/zyantific/zasm">zasm</a>.</p><p>Here’s what it’s capable of as of now:</p><ul><li>Program size estimation</li><li>Program <a href="/posts/obfuscator-pt-1/#acronyms">assembler</a></li><li>One-line JMP encoder</li><li>Node cursor (simplify the usages of assembler-&gt;setCursor)</li><li>Program instructions info debug dump</li><li><a href="/posts/obfuscator-pt-1/#acronyms">Disasm</a> block of code</li><li><a href="/posts/obfuscator-pt-1/#acronyms">Disasm</a> single instruction</li><li><a href="/posts/obfuscator-pt-1/#acronyms">GP</a> registers converter:<ul><li>32-bit to 64-bit</li><li>64-bit to 32-bit</li><li>64-bit to 16-bit</li><li>64-bit to 8-bit</li></ul></li><li><a href="/posts/obfuscator-pt-1/#acronyms">JCC</a>/JMP matcher</li><li><a href="/posts/obfuscator-pt-1/#acronyms">RET</a> matcher</li><li>Instruction that affects <a href="/posts/obfuscator-pt-1/#acronyms">IP</a> matcher</li><li><a href="/posts/obfuscator-pt-1/#acronyms">JCC</a>/JMP follower</li><li><a href="/posts/obfuscator-pt-1/#acronyms">Operand</a> size calculator</li><li><code>zasm::Reg</code> converter:<ul><li>to <code>zasm::x86::Gp</code></li><li>to <a href="/posts/obfuscator-pt-1/#acronyms">Root GP</a> <code>zasm::x86::Gp</code></li></ul></li><li><a href="/posts/obfuscator-pt-1/#acronyms">SP</a> matcher</li></ul><h2 id="configuration-parser">Configuration parser</h2><p>For now, only CLI arguments are supported as a config provider, but implementing any other sources isn’t such a hard task since they’re implemented in a kinda abstract way. I think at some point I’m gonna implement a <code>.toml</code> config parser.</p><h3 id="transform-configuration">Transform configuration</h3><p>Currently, there are three types of transform config var.</p><h4 id="global">Global</h4><p>Global transform config var is a configuration parameter that should be defined once for all functions. Could store all types of data using the <code>std::any</code> container.</p><h4 id="per-function">Per function</h4><p>Technically, this variable functions in the same manner as global configuration variables. However, it resets to its default value at the beginning of each function, necessitating configuration within each function. Alternatively, if you designate this per-function variable as a global variable, the obfuscator will automatically override the default value. This means you have the option to set the variable either individually for each function or just once for all functions. It is capable of storing any type of data within its <code>std::any</code> container.</p><h4 id="shared-config">Shared config</h4><p>A shared config is a configuration that is common across all transforms. It includes parameters such as the number of times a transform needs to be re-run, the probability of its application, and other similar settings.</p><p>Shared config vars are always optional, you can not mark it as required.</p><p>This configuration should be configured per each function, but if you pass it as a global var, it would override the default value and this config would be applied for all functions for this transform.</p><h4 id="obfuscator-config">Obfuscator config</h4><p>A struct that for now contains only the path to the binary that it should protect.</p><h4 id="function-parser-config">Function parser config</h4><p>Store options for the <a href="/posts/obfuscator-pt-1/#acronyms">MAP</a>/<a href="/posts/obfuscator-pt-1/#acronyms">PDB</a> parsers.</p><h3 id="cli-interface">CLI Interface</h3><p>CLI is implemented in the easiest way it can be implemented.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span>[  <span style="color:#e06c75">info</span>  ] <span style="color:#e06c75">Available</span> <span style="color:#e06c75">options</span>:
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#56b6c2">-</span><span style="color:#e06c75">h</span>, <span style="color:#56b6c2">--</span><span style="color:#e06c75">help</span>                   <span style="color:#56b6c2">--</span> <span style="color:#e06c75">This</span> <span style="color:#e06c75">message</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#56b6c2">-</span><span style="color:#e06c75">pdb</span>         [<span style="color:#e06c75">path</span>]          <span style="color:#56b6c2">--</span> <span style="color:#e06c75">Set</span> <span style="color:#e06c75">custom</span> .<span style="color:#e06c75">pdb</span> <span style="color:#e06c75">file</span> <span style="color:#e06c75">location</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#56b6c2">-</span><span style="color:#e06c75">map</span>         [<span style="color:#e06c75">path</span>]          <span style="color:#56b6c2">--</span> <span style="color:#e06c75">Set</span> <span style="color:#e06c75">custom</span> .<span style="color:#e06c75">map</span> <span style="color:#e06c75">file</span> <span style="color:#e06c75">location</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#56b6c2">-</span><span style="color:#e06c75">f</span>           [<span style="color:#e06c75">name</span>]          <span style="color:#56b6c2">--</span> <span style="color:#e06c75">Start</span> <span style="color:#c678dd">new</span> <span style="color:#e06c75">function</span> <span style="color:#e06c75">configuration</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#56b6c2">-</span><span style="color:#e06c75">t</span>           [<span style="color:#e06c75">name</span>]          <span style="color:#56b6c2">--</span> <span style="color:#e06c75">Start</span> <span style="color:#c678dd">new</span> <span style="color:#e06c75">transform</span> <span style="color:#e06c75">configuration</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#56b6c2">-</span><span style="color:#e06c75">g</span>           [<span style="color:#e06c75">name</span>]          <span style="color:#56b6c2">--</span> <span style="color:#e06c75">Start</span> <span style="color:#c678dd">new</span> <span style="color:#e06c75">transform</span> <span style="color:#e06c75">global</span> <span style="color:#e06c75">configuration</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span>           [<span style="color:#e06c75">name</span>] [<span style="color:#e06c75">value</span>]  <span style="color:#56b6c2">--</span> <span style="color:#e06c75">Push</span> <span style="color:#e06c75">value</span>
</span></span><span style="display:flex"><span>[  <span style="color:#e06c75">info</span>  ]  
</span></span><span style="display:flex"><span>[  <span style="color:#e06c75">info</span>  ] <span style="color:#e06c75">Examples</span>:
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#e06c75">obfuscator</span> <span style="color:#e06c75">hehe</span>.<span style="color:#e06c75">exe</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">f</span> <span style="color:#e06c75">main</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">t</span> <span style="color:#e06c75">TransformName</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeName</span> <span style="color:#d19a66">1337</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#e06c75">obfuscator</span> <span style="color:#e06c75">hehe</span>.<span style="color:#e06c75">exe</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">f</span> <span style="color:#e06c75">main</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">t</span> <span style="color:#e06c75">TransformName</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeName</span> <span style="color:#d19a66">1337</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">g</span> <span style="color:#e06c75">TransformName</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeGlobalName</span> <span style="color:#d19a66">1337</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#e06c75">obfuscator</span> <span style="color:#e06c75">hehe</span>.<span style="color:#e06c75">exe</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">f</span> <span style="color:#e06c75">main</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">t</span> <span style="color:#e06c75">TransformName</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeName</span> <span style="color:#d19a66">1337</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeName0</span> <span style="color:#d19a66">1337</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">g</span> <span style="color:#e06c75">TransformName</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeGlobalName</span> <span style="color:#d19a66">1337</span>
</span></span><span style="display:flex"><span><span style="color:#56b6c2">|</span>        [  <span style="color:#e06c75">info</span>  ] <span style="color:#e06c75">obfuscator</span> <span style="color:#e06c75">hehe</span>.<span style="color:#e06c75">exe</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">map</span> <span style="color:#e06c75">mymap</span>.<span style="color:#e06c75">map</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">pdb</span> <span style="color:#e06c75">mypdb</span>.<span style="color:#e06c75">pdb</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">f</span> <span style="color:#e06c75">main</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">t</span> <span style="color:#e06c75">TransformName</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeName</span> <span style="color:#d19a66">1337</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeName0</span> <span style="color:#d19a66">1337</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">g</span> <span style="color:#e06c75">TransformName</span> <span style="color:#56b6c2">-</span><span style="color:#e06c75">v</span> <span style="color:#e06c75">SomeGlobalName</span> <span style="color:#d19a66">1337</span>
</span></span></code></pre></div><h2 id="code-analysis">Code analysis</h2><p>Now, when we know the needed configurations and function bounds, we can finally start analyzing the functions that we need to protect.</p><p>Code analysis consists of six phases within the <a href="/posts/obfuscator-pt-1/#acronyms">Basic Block</a> decomposition and four analysis passes.</p><p>Code analysis so far is the most tedious part of this project, although I enjoyed implementing it. It took me a really long time to implement everything I wanted it to do, but some parts of it are still not implemented in the way I want them to work, hopefully, I will get to it in the next parts of this series.</p><p><img src="/posts/obfuscator-pt-1/diags/analysis.png" alt="analysis_diag"></p><h3 id="basic-block-decomposition">Basic Block decomposition</h3><p><a href="/posts/obfuscator-pt-1/#acronyms">Basic blocks or BBs</a> are the sequences of instructions in code that have a single entry point and at most two exit points.</p><p><img src="/posts/obfuscator-pt-1/pics/bbs.jpg" alt="bbs"></p><p>To decompose a basic block we need to <a href="/posts/obfuscator-pt-1/#acronyms">disassemble</a> instructions one by one until we hit a <a href="/posts/obfuscator-pt-1/#acronyms">JCC</a>/JMP.</p><p>At this moment BB decomposition also includes the logic for <a href="/posts/obfuscator-pt-1/#acronyms">Jump Tables</a> expansions.</p><h4 id="phase-1-decomposition">Phase 1: Decomposition</h4><p>The whole <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> decomposition is made in a single recursive function that will assemble a new BB until its end is hit, and then it will start decomposing a new one.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#c678dd">template</span> <span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">pe</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">any_image_t</span> <span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span>
</span></span><span style="display:flex"><span><span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">shared_ptr</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">bb_t</span><span style="color:#56b6c2">&gt;</span> <span style="color:#e06c75">Instance</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;::</span><span style="color:#e06c75">process_bb</span>(<span style="color:#c678dd">const</span> <span style="color:#e06c75">rva_t</span> <span style="color:#e06c75">rva</span>) {
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// Initialization stuff here ...
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>
</span></span><span style="display:flex"><span>    <span style="color:#c678dd">for</span> (<span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">size_t</span> <span style="color:#e06c75">offset</span> <span style="color:#56b6c2">=</span> <span style="color:#d19a66">0</span>; <span style="color:#56b6c2">!</span><span style="color:#e06c75">is_rva_oob</span>(<span style="color:#e06c75">rva</span> <span style="color:#56b6c2">+</span> <span style="color:#e06c75">offset</span>); <span style="color:#e06c75">offset</span> <span style="color:#56b6c2">+=</span> <span style="color:#e06c75">insn</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">getLength</span>()) {
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// Decode the instruction
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#e06c75">insn</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">decoder_</span>.<span style="color:#e06c75">decode_insn_detail</span>(<span style="color:#e06c75">data_start</span> <span style="color:#56b6c2">+</span> <span style="color:#e06c75">offset</span>, <span style="color:#e06c75">easm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">kDefaultSize</span>, (<span style="color:#e06c75">virtual_address</span> <span style="color:#56b6c2">+</span> <span style="color:#e06c75">offset</span>).<span style="color:#e06c75">inner</span>());
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// Saving instruction to the current BB struct
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#7f848e">// If we hit a JCC/JMP, the analysis would start processing it automatically
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#c678dd">const</span> <span style="color:#c678dd">auto</span> <span style="color:#e06c75">insn_desc</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">push_last_instruction</span>(<span style="color:#e06c75">result</span>, <span style="color:#e06c75">rva</span> <span style="color:#56b6c2">+</span> <span style="color:#e06c75">offset</span>, <span style="color:#e06c75">insn</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">getLength</span>());
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// Finish BB as soon as RET has been hit
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#c678dd">if</span> (<span style="color:#e06c75">easm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">is_ret</span>(<span style="color:#56b6c2">*</span><span style="color:#e06c75">insn</span>)) {
</span></span><span style="display:flex"><span>            <span style="color:#c678dd">break</span>;
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// Ignoring anything that wouldn't affect IP
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#c678dd">if</span> (<span style="color:#56b6c2">!</span><span style="color:#e06c75">insn_desc</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">is_jump</span>() <span style="color:#56b6c2">&amp;&amp;</span> <span style="color:#56b6c2">!</span>(<span style="color:#e06c75">insn_desc</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">flags</span> <span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">UNABLE_TO_ESTIMATE_JCC</span>)) {
</span></span><span style="display:flex"><span>            <span style="color:#c678dd">continue</span>;
</span></span><span style="display:flex"><span>        }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// Ending bb as soon as we hit JCC/JMP
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#c678dd">break</span>;
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><h4 id="phase-2-jumptables-expansion-preparations">Phase 2: JumpTables expansion preparations</h4><p>If you don’t know what <a href="/posts/obfuscator-pt-1/#acronyms">JumpTables</a> are, essentially when you write a code with a switch, the compiler instead of chaining <a href="/posts/obfuscator-pt-1/#acronyms">JZ</a>/<a href="/posts/obfuscator-pt-1/#acronyms">JNZ</a> would construct a table with handlers for each case, and use the operand that you pass as an index. Sometimes it could also optimize the expression that you pass and construct some weird expressions with discrete math to generate the index from your argument.</p><p>The most common stub for <a href="/posts/obfuscator-pt-1/#acronyms">JumpTables</a> looks like this:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">cmp</span>     <span style="color:#e06c75">eax</span>, <span style="color:#d19a66">0x6</span> <span style="color:#7f848e">; eax - index
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">ja</span>      <span style="color:#d19a66">0x140001163</span> <span style="color:#7f848e">; jump to default case
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">lea</span>     <span style="color:#e06c75">rdx</span>, [<span style="color:#e06c75">rel</span> <span style="color:#e06c75">__dos_header</span>] <span style="color:#7f848e">; base address
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">mov</span>     <span style="color:#e06c75">ecx</span>, <span style="color:#e06c75">dword</span> [<span style="color:#e06c75">rdx</span>+<span style="color:#e06c75">rax</span>*<span style="color:#d19a66">4</span>+<span style="color:#d19a66">0x1188</span>] <span style="color:#7f848e">; get the jumptable entry
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">add</span>     <span style="color:#e06c75">rcx</span>, <span style="color:#e06c75">rdx</span> <span style="color:#7f848e">; add base (it stores RVAs)
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">jmp</span>     <span style="color:#e06c75">rcx</span> <span style="color:#7f848e">; jmp to the branch
</span></span></span></code></pre></div><p>So what we need to do, is find the reference to a <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a>, get its size, remove the JMP instruction and chain JZs instead.
Sounds trivial, however, it isn’t as easy as it sounds because as always the hardest things are these small details. Probably this is why <a href="https://oreans.com/">Themida</a> still doesn’t support the code with <a href="/posts/obfuscator-pt-1/#acronyms">JumpTables</a> in it.</p><h5 id="phase-2-1-jumptables-collector">Phase 2-1: JumpTables collector</h5><p>To expand something, we first need to find something, right? To collect all the <a href="/posts/obfuscator-pt-1/#acronyms">JumpTables</a> we are first iterating through all the <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a> and looking for instructions where we were unable to estimate the <a href="/posts/obfuscator-pt-1/#acronyms">JCC</a>/<a href="/posts/obfuscator-pt-1/#acronyms">JMP</a> destination.</p><p>We are unable to estimate it because our decomposer doesn’t symbolically execute the code that it’s analyzing, thus it doesn’t know what’s stored in the <a href="/posts/obfuscator-pt-1/#acronyms">JMP</a> operand because it’s a register.</p><p>Once we find the instruction where we were unable to estimate the next branch, we have to start reverse-iterating all the instructions that we have seen before this one.</p><p>While we’re iterating through all the instructions that should be executed before this jump, we have to match for two things:</p><ul><li>The so-called <code>load_index</code> instruction that looks like this, in my example, is <code>mov ecx, dword [rdx+rax*4+0x1188]</code>, where the <code>0x1188</code> is the <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> start <a href="/posts/obfuscator-pt-1/#acronyms">RVA</a>.</li><li>And <code>base_mov</code>, is an instruction that moves the image base to some register that is being in use in the <code>load_index</code> instruction.</li></ul><h5 id="phase-2-2-jumptables-size-estimation">Phase 2-2: JumpTables size estimation</h5><p>This part is a bit tricky because normally you’ll see <a href="/posts/obfuscator-pt-1/#acronyms">JE</a>/<a href="/posts/obfuscator-pt-1/#acronyms">JNE</a> instructions that would check for the <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> bounds first. Like this <code>cmp eax, 0x6; ja somewhere</code> in my example.</p><p>But the thing is, this instruction would be inserted into binary <strong>only</strong> when the compiler is not sure that you are handling all cases. This basically means that if you make a switch with 256 entries and compare the <code>uint8_t</code> value <em>(its max value is <code>0xFF</code>)</em>, you will see a stub like this.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">lea</span>     <span style="color:#e06c75">rdx</span>, [<span style="color:#e06c75">rel</span> <span style="color:#e06c75">__dos_header</span>] <span style="color:#7f848e">; base_mov
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">mov</span>     <span style="color:#e06c75">eax</span>, <span style="color:#e06c75">dword</span> [<span style="color:#e06c75">rdx</span>+<span style="color:#e06c75">rax</span>*<span style="color:#d19a66">4</span>+<span style="color:#d19a66">0x1e08</span>] <span style="color:#7f848e">; load_index
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">add</span>     <span style="color:#e06c75">rax</span>, <span style="color:#e06c75">rdx</span> <span style="color:#7f848e">; add the base
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">jmp</span>     <span style="color:#e06c75">rax</span> <span style="color:#7f848e">; jmp to reg
</span></span></span></code></pre></div><p>As you can see, there’s no bounds check and thus we can’t relate to this instruction in our code. We need to think of a different approach.</p><p>And the easiest approach is to just brute-force its entries.
But with just a straight brute force there could potentially be some collisions with the other <a href="/posts/obfuscator-pt-1/#acronyms">JumpTables</a>, that we can hit.</p><p>So what we have to do is first find all the start addresses of the <a href="/posts/obfuscator-pt-1/#acronyms">JumpTables</a>, then brute-force its entries while checking whether we’re hitting an entry from a different <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> or not.</p><p>The implementation of such an algorithm is quite big so I wouldn’t insert my code snippets for this, it would be much easier to just check the <a href="https://github.com/es3n1n/obfuscator">sources</a>.</p><h4 id="phase-3-bb-splitting">Phase 3: BB splitting</h4><p>If you understood how the <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> decomposition works, then you may have understood its general flaw. The way it disassembles and decomposes basic blocks linearly would produce multiple duplications of the basic blocks.</p><p><em>Please note, that at this phase there’s also an <code>update_refs</code> job that obfuscator is doing, but it isn’t really related to this, it’s just updating all the instructions references within the analysis stored info, so there’s no point in discussing this, this is <em>just how I’m linking analysis</em> info with the zasm nodes.</em></p><p>For example, for the following code:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span>, <span style="color:#d19a66">1337</span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">je</span> <span style="color:#e06c75">label_1</span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span>, <span style="color:#d19a66">1234</span>
</span></span><span style="display:flex"><span><span style="color:#e06c75">label_1:</span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">ret</span>
</span></span></code></pre></div><p>The output basic blocks from the <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> decomposer would be like this:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#7f848e">; Basic block 1
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span> <span style="color:#d19a66">1337</span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">je</span> <span style="color:#e06c75">label_1</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">; Basic block 2
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">ret</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">; Basic block 3
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span>, <span style="color:#d19a66">1234</span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">ret</span>
</span></span></code></pre></div><p>As you can see, there’s a duplicated <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> that contains the same instruction in multiple <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a>. This instruction is RET and that’s because we’re following all the branches and defining new <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a> if we don’t see any <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> that starts at this address.</p><p>To fix that, we have to find all the intersections between all the <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a> and split them so that we would have basic blocks like this, for the example below:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#7f848e">; Basic block 1
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span>, <span style="color:#d19a66">1337</span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">je</span> <span style="color:#e06c75">label_1</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">; Basic block 2
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">mov</span> <span style="color:#e06c75">eax</span>, <span style="color:#d19a66">1234</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">; Basic block 3
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">ret</span>
</span></span></code></pre></div><h4 id="phase-4-jumptables-expansion-and-some-other-analysis-shenanigans">Phase 4: JumpTables expansion and some other analysis shenanigans</h4><h5 id="phase-4-1-jumptables-expansion">Phase 4-1: JumpTables expansion</h5><p>Now, when we are sure that we’ve already collected all the needed information about <a href="/posts/obfuscator-pt-1/#acronyms">JumpTables</a> within the function, we can start expanding them to the chained <a href="/posts/obfuscator-pt-1/#acronyms">JZ</a> expressions.</p><p>The whole process of this is quite easy, all we have to do is:</p><ul><li>Transform the load_index instruction from <code>mov ecx, dword [rdx+rax*4+0x1188]</code> to <code>lea ecx, dword [rax*4]</code> so that we would get instead of the case RVA, its offset in the <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a></li><li>Iterate through all <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> entries, then:<ul><li>Compare the index</li><li>Analyze the case</li><li>Jump to the newly analyzed <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a> from the new case</li></ul></li></ul><p>And in the end, the whole “unwrapped” <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> would look as follows:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">lea</span>     <span style="color:#e06c75">rax</span>, [<span style="color:#e06c75">rax</span>*<span style="color:#d19a66">4</span>] <span style="color:#7f848e">; load index
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">cmp</span>     <span style="color:#e06c75">rax</span>, <span style="color:#d19a66">0x0</span> <span style="color:#7f848e">; case 0
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">je</span>      <span style="color:#d19a66">0x14000b87b</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">cmp</span>     <span style="color:#e06c75">rax</span>, <span style="color:#d19a66">0x4</span> <span style="color:#7f848e">; case 1
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">je</span>      <span style="color:#d19a66">0x14000b872</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">cmp</span>     <span style="color:#e06c75">rax</span>, <span style="color:#d19a66">0x8</span> <span style="color:#7f848e">; case 2
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#61afef;font-weight:700">je</span>      <span style="color:#d19a66">0x14000b869</span>
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">; ...
</span></span></span></code></pre></div><h5 id="phase-4-2-rescheduled-cf-changer-info-updates">Phase 4-2: Rescheduled CF changer info updates</h5><p>In the analysis module, it collects all the “non-default” <a href="/posts/obfuscator-pt-1/#acronyms">CF</a> changes of the instruction and caches it, for example, for the instruction <code>JMP</code> there would be 1 <a href="/posts/obfuscator-pt-1/#acronyms">CF</a> changer entry with its type set to <code>JMP</code>, for <code>JE</code> instruction there would be two <a href="/posts/obfuscator-pt-1/#acronyms">CF</a> changers, one if the condition is met and one if condition isn’t met.</p><p>Thus, at the time of <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> expansion, there could be some cases where it was unable to detect this info, and to do this, the analyzer is re-scheduling the update of this info, and we have to update it manually.</p><h5 id="phase-4-3-splitting-bbs">Phase 4-3: Splitting BBs</h5><p>Since after the <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> expansions, we added some new basic blocks, we also need to split them in the same way as we did it before</p><h4 id="phase-5-jmp-insertion">Phase 5: Jmp insertion</h4><p>After all these <a href="/posts/obfuscator-pt-1/#acronyms">JumpTable</a> expansion phases, some fresh new <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a> aren’t ending with a jump and their next <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a> wouldn’t be the ones, that it expects.</p><p>To fix this, we have to iterate through all <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a>, check its next nodes and verify that it is the one that it expects, and insert a jump to the right one, if not.</p><h4 id="phase-6-tree-update">Phase 6: Tree update</h4><p>In the <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> there are two vectors with <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> <a href="/posts/obfuscator-pt-1/#acronyms">successors</a> and <a href="/posts/obfuscator-pt-1/#acronyms">predecessors</a>. After all the analysis phases there could be some invalid data about the <a href="/posts/obfuscator-pt-1/#acronyms">successors</a>, and <a href="/posts/obfuscator-pt-1/#acronyms">predecessors</a> after we split them.</p><p>To make sure that this info is up to date, we need to iterate through all the <a href="/posts/obfuscator-pt-1/#acronyms">CF</a> changes and keep track of <a href="/posts/obfuscator-pt-1/#acronyms">successors</a>, then after we have the list of <a href="/posts/obfuscator-pt-1/#acronyms">successors</a>, we can update the list of <a href="/posts/obfuscator-pt-1/#acronyms">predecessors</a>.</p><h3 id="observer">Observer</h3><p>In the <a href="https://github.com/zyantific/zasm">zasm</a> library, we can create our custom <code>Observers</code> that would be notified as soon as a new node gets inserted/deleted to the program, by using these callbacks we can append new instructions to the <a href="/posts/obfuscator-pt-1/#acronyms">basic blocks</a>.</p><p>Due to lack of time implementation of this observer isn’t as proper as it could be, but I’m planning on rewriting it.</p><h3 id="passes">Passes</h3><p>After all of these, the analyzer starts applying analysis passes, there are only five passes as of now.</p><h4 id="pass-1-image-references-collector">Pass 1: Image references collector</h4><p>After we successfully decomposed the function to our custom structs, the references to other parts of this program are just the immediate addresses and/or memory references, which we have to manually resolve, but before resolving anything, we have to collect them first.</p><p>So what this pass is doing is it’s just looking for the immediate addresses and tries to check if they’re in the image range, if so, it stores it in the <code>unordered_map</code>.</p><h4 id="pass-2-collect-the-lookup-table">Pass 2: Collect the lookup table</h4><p>Store the instructions in an <code>unordered_map</code> with its <a href="/posts/obfuscator-pt-1/#acronyms">RVA</a> set as the key.</p><h4 id="pass-3-lrureg">Pass 3: LRUReg</h4><p><code>LRUReg</code> is a mechanism that is implemented within the analysis module. LRU stands for the <code>Least Recently Used</code>, so what it’s doing is it tracks what registers were used recently and updates its cache accordingly. We would use this class later in the transformations.</p><p>Generally in programming LRU caching is used to reduce the lifetime of the cache, however, this is not the case why I used this mechanism in my project. Instead, by tracking the least recently used registers we can find what registers were uncommon/common for the analyzed function, thus, in transformations later we could easily generate a “random” register that wasn’t in use by the function.</p><h5 id="varalloc">VarAlloc</h5><p><code>VarAlloc</code> is a mechanism that was created along with <code>LRUReg</code> in order to simplify the allocations of variables in the transforms logic.</p><p>For example, if in our transform we need to create a variable for some mathematical expression, to do that the only thing we need to do is:</p><ul><li>Create a var alloc instance</li></ul><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#c678dd">auto</span> <span style="color:#e06c75">var_alloc</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">function</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">var_alloc</span>();
</span></span></code></pre></div><ul><li>Allocate variable</li></ul><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#c678dd">auto</span> <span style="color:#e06c75">var</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">var_alloc</span>.<span style="color:#e06c75">get_gp32</span>();
</span></span></code></pre></div><ul><li>Push its value on the stack</li></ul><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#e06c75">var_alloc</span>.<span style="color:#e06c75">push</span>(<span style="color:#e06c75">assembler</span>);
</span></span></code></pre></div><ul><li>Generate math expression</li></ul><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">add</span>(<span style="color:#e06c75">var</span>, <span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Imm</span>(<span style="color:#d19a66">5</span>)); <span style="color:#7f848e">// var = var + 5
</span></span></span></code></pre></div><ul><li>Restore value from the stack</li></ul><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#e06c75">var_alloc</span>.<span style="color:#e06c75">pop</span>(<span style="color:#e06c75">assembler</span>);
</span></span></code></pre></div><p>For now, <code>VarAlloc</code> can only allocate variables in registers.</p><p>Also, to keep the consistency of the program <a href="/posts/obfuscator-pt-1/#acronyms">EFLAGS</a>, <code>VarAlloc</code> also pushes the flags on the stack and restores them afterward. This is not ideal, ideally, the analysis should track what flags are being in use(it already collects what instruction affects what flags) and make sure we wouldn’t override them.</p><h4 id="pass-4-label-references">Pass 4: Label references</h4><p>Now, when we have already collected all the image references, we need to resolve the ones that are within the function and instead of raw addresses, we have to swap the operand to the zasm’s Label. This is needed because when we are going to compile this code back, the addresses won’t be the same and the original function will be overwritten with random bytes. So instead of just raw addresses we would bind the destination to the internal nodes that are stored within the <a href="https://github.com/zyantific/zasm">zasm’s</a> program.</p><h2 id="other-parts-of-the-core">Other parts of the core</h2><h3 id="mathop">Mathop</h3><p><code>mathop</code> is a math expression generator, short for <code>math operations</code>, designed to emulate various mathematical operations and convert their reverse operations into x86 instructions. <code>mathop</code> currently supports the following operations:</p><ul><li>Add</li><li>Sub</li><li>Inc</li><li>Dec</li><li>Neg</li><li>Not</li></ul><p>Adding your own operations to <code>mathop</code> is pretty easy, you have to use 1 macro in <code>.hpp</code>:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#7f848e">/// ^
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#e06c75">MATHOP_OPERATION_TWO_OPS</span>(<span style="color:#e06c75">Xor</span>);
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">/// -
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#e06c75">MATHOP_OPERATION_ONE_OP</span>(<span style="color:#e06c75">Neg</span>);
</span></span></code></pre></div><p>And then implement its logic in a <code>.cpp</code> file:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#7f848e">/// \brief Emulate the math operation under the two operands
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param op1 lhs
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param op2 rhs
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \return emulated result
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#e06c75">ArgumentImm</span> <span style="color:#e06c75">Xor</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">emulate</span>(<span style="color:#e06c75">ArgumentImm</span> <span style="color:#e06c75">op1</span>, <span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">optional</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">ArgumentImm</span><span style="color:#56b6c2">&gt;</span> <span style="color:#e06c75">op2</span>) <span style="color:#c678dd">const</span> {
</span></span><span style="display:flex"><span>    <span style="color:#e06c75">ArgumentImm</span> <span style="color:#e06c75">result</span>;
</span></span><span style="display:flex"><span>    <span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">visit</span>(
</span></span><span style="display:flex"><span>        [<span style="color:#56b6c2">&amp;</span>]<span style="color:#56b6c2">&lt;</span><span style="color:#c678dd">typename</span> <span style="color:#e06c75">Ty</span><span style="color:#56b6c2">&gt;</span>(<span style="color:#e06c75">Ty</span><span style="color:#56b6c2">&amp;&amp;</span> <span style="color:#e06c75">op1_value</span>) <span style="color:#56b6c2">-&gt;</span> <span style="color:#e5c07b">void</span> { <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>            <span style="color:#e06c75">result</span>.<span style="color:#e06c75">emplace</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">decay_t</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Ty</span><span style="color:#56b6c2">&gt;&gt;</span>(<span style="color:#e06c75">op1_value</span> <span style="color:#56b6c2">^</span> <span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">get</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">decay_t</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Ty</span><span style="color:#56b6c2">&gt;&gt;</span>(<span style="color:#56b6c2">*</span><span style="color:#e06c75">op2</span>));
</span></span><span style="display:flex"><span>        },
</span></span><span style="display:flex"><span>        <span style="color:#e06c75">op1</span>);
</span></span><span style="display:flex"><span>    <span style="color:#c678dd">return</span> <span style="color:#e06c75">result</span>;
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">/// \brief Lift the revert operation for this math operation
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param assembler zasm assembler
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param operand dst operand
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param argument optional rhs
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#e5c07b">void</span> <span style="color:#e06c75">Xor</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">lift_revert</span>(<span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">x86</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Assembler</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">assembler</span>, <span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">x86</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Gp</span> <span style="color:#e06c75">operand</span>, <span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">optional</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Argument</span><span style="color:#56b6c2">&gt;</span> <span style="color:#e06c75">argument</span>) <span style="color:#c678dd">const</span> {
</span></span><span style="display:flex"><span>    <span style="color:#e06c75">lift</span>(
</span></span><span style="display:flex"><span>        <span style="color:#e06c75">argument</span>, <span style="color:#e06c75">detail</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">none</span>,
</span></span><span style="display:flex"><span>        [<span style="color:#e06c75">assembler</span>, <span style="color:#e06c75">operand</span>](<span style="color:#c678dd">const</span> <span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">x86</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Gp</span> <span style="color:#e06c75">reg</span>) <span style="color:#56b6c2">-&gt;</span> <span style="color:#e5c07b">void</span> { <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>            <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">xor_</span>(<span style="color:#e06c75">operand</span>, <span style="color:#e06c75">reg</span>);
</span></span><span style="display:flex"><span>        },
</span></span><span style="display:flex"><span>        [<span style="color:#e06c75">assembler</span>, <span style="color:#e06c75">operand</span>](<span style="color:#c678dd">const</span> <span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Imm</span> <span style="color:#e06c75">imm</span>) <span style="color:#56b6c2">-&gt;</span> <span style="color:#e5c07b">void</span> { <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>            <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">xor_</span>(<span style="color:#e06c75">operand</span>, <span style="color:#e06c75">imm</span>);
</span></span><span style="display:flex"><span>        });
</span></span><span style="display:flex"><span>}
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">/// \brief Generate a random second operand
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param lhs Operand 1
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \return Generated operand
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#e06c75">ArgumentImm</span> <span style="color:#e06c75">Xor</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">generate_rhs</span>(<span style="color:#c678dd">const</span> <span style="color:#e06c75">ArgumentImm</span> <span style="color:#e06c75">lhs</span>) <span style="color:#c678dd">const</span> {
</span></span><span style="display:flex"><span>    <span style="color:#c678dd">return</span> <span style="color:#e06c75">detail</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">generate_random_argument_in_range</span>(<span style="color:#e06c75">lhs</span>);
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p><code>mathop</code> can generate the RHS values for the operations, also it supports the <code>zasm</code> registers passed as the <code>LHS</code>/<code>RHS</code> and operate on their values (only for lifting).</p><p>I am planning on expanding <code>mathop</code>, adding lifters for not only revert operations and some other things. But for now, it will do its job.</p><h2 id="transforms-design">Transforms design</h2><p>Transform or transformation could be treated in the same way as optimization passes in compilers, although instead of optimizing code they instead obfuscate it. For example, obfuscation transform could replace <code>a+b</code> operation with <code>a-(-b)</code> in order to make the code harder to understand.</p><p>Let’s break down how would you add your own transformations to the obfuscator.</p><p>First, you need to create a <code>.hpp</code> file and decide where you would apply your transformations, it could be one(or multiple) of:</p><ul><li>Function transform</li><li><a href="/posts/obfuscator-pt-1/#acronyms">BB</a> transform</li><li><a href="https://github.com/zyantific/zasm">zasm</a> node transform</li><li>Analysis instruction transform</li></ul><p>For example, let’s create a basic block transform that would add an <code>NOP</code> instruction at the beginning of each basic block.</p><h3 id="implementing-our-own-transform">Implementing our own transform</h3><p>To do that, we have to derive the transformation from <code>BBTransform</code> class:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#c678dd">template</span> <span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">pe</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">any_image_t</span> <span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span>
</span></span><span style="display:flex"><span><span style="color:#c678dd">class</span> <span style="color:#e5c07b">Nops</span> <span style="color:#c678dd">final</span> <span style="color:#56b6c2">:</span> <span style="color:#c678dd">public</span> <span style="color:#e06c75">BBTransform</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span> {
</span></span><span style="display:flex"><span><span style="color:#c678dd">public</span><span style="color:#56b6c2">:</span>
</span></span><span style="display:flex"><span>    
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><p>Then, implement the abstract method that actually applies the transformation.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#c678dd">template</span> <span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">pe</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">any_image_t</span> <span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span>
</span></span><span style="display:flex"><span><span style="color:#c678dd">class</span> <span style="color:#e5c07b">Nops</span> <span style="color:#c678dd">final</span> <span style="color:#56b6c2">:</span> <span style="color:#c678dd">public</span> <span style="color:#e06c75">BBTransform</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span> {
</span></span><span style="display:flex"><span><span style="color:#c678dd">public</span><span style="color:#56b6c2">:</span>
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// \brief Transform basic block
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param ctx Transform context
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param function Routine that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param bb BB that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e5c07b">void</span> <span style="color:#e06c75">run_on_bb</span>(<span style="color:#e06c75">TransformContext</span><span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">ctx</span>, <span style="color:#e06c75">Function</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;*</span> <span style="color:#e06c75">function</span>, <span style="color:#e06c75">analysis</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">bb_t</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">bb</span>) <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">//
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    }
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><p>Nice. Now we need to add the <code>NOP</code> instruction, to do that we have to get the assembler whose cursor is set to the beginning of the <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> and call the <code>nop</code> function from the assembler object.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#c678dd">template</span> <span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">pe</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">any_image_t</span> <span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span>
</span></span><span style="display:flex"><span><span style="color:#c678dd">class</span> <span style="color:#e5c07b">Nops</span> <span style="color:#c678dd">final</span> <span style="color:#56b6c2">:</span> <span style="color:#c678dd">public</span> <span style="color:#e06c75">BBTransform</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span> {
</span></span><span style="display:flex"><span><span style="color:#c678dd">public</span><span style="color:#56b6c2">:</span>
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// \brief Transform basic block
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param ctx Transform context
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param function Routine that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param bb BB that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e5c07b">void</span> <span style="color:#e06c75">run_on_bb</span>(<span style="color:#e06c75">TransformContext</span><span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">ctx</span>, <span style="color:#e06c75">Function</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;*</span> <span style="color:#e06c75">function</span>, <span style="color:#e06c75">analysis</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">bb_t</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">bb</span>) <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">/// or `cursor-&gt;before(bb-&gt;instructions.at(0)-&gt;node_ref)`
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#c678dd">auto</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">assembler</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">function</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">cursor</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">before</span>(<span style="color:#e06c75">bb</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">node_at</span>(<span style="color:#d19a66">0</span>)).<span style="color:#e06c75">value</span>();
</span></span><span style="display:flex"><span>        <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">nop</span>();
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><p>Now, the implementation of this transform is finished, but we also have to push it to the scheduler list, to do that we need to open the <code>obfuscator/transforms/startup.cpp</code> file and add it there</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="display:flex"><span>void startup_scheduler() {
</span></span><span style="display:flex"><span>    auto&amp; scheduler = TransformScheduler::get();
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    scheduler.register_transform&lt;transforms::ConstantCrypt&gt;();
</span></span><span style="display:flex"><span>    scheduler.register_transform&lt;transforms::Substitution&gt;();
</span></span><span style="display:flex"><span>    scheduler.register_transform&lt;transforms::BogusControlFlow&gt;();
</span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700">+   scheduler.register_transform&lt;transforms::Nops&gt;();
</span></span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700"></span>}
</span></span></code></pre></div><p>This is it! Transform is finished, but maybe we also need to add some variables that could be set for this transform. Something like a counter how many nops do we need to insert?</p><p>To do that, we need to override the <code>init_config</code> method and initialize our vars there.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#7f848e">/// \brief Optional callback that initializes config variables
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:700">init_config</span>() <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>    <span style="color:#c678dd">this</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">mode</span> <span style="color:#56b6c2">=</span> <span style="color:#56b6c2">&amp;</span><span style="color:#c678dd">this</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">new_var</span>(
</span></span><span style="display:flex"><span>        <span style="color:#d19a66">0</span>, <span style="color:#7f848e">// unique index
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#98c379">"mode"</span>, <span style="color:#7f848e">// name
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#e5c07b">false</span>, <span style="color:#7f848e">// is_required
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#e06c75">TransformConfig</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Var</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Type</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">PER_FUNCTION</span>, <span style="color:#7f848e">// type
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>        <span style="color:#d19a66">1</span> <span style="color:#7f848e">// default_value
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    );
</span></span><span style="display:flex"><span>    <span style="color:#e06c75">mode</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">short_description</span>(<span style="color:#98c379">"counter goes brr"</span>);
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>And to use it afterward all we have to do is call its <code>-&gt;template value</code> function.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#7f848e">/// \brief Transform basic block
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param ctx Transform context
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param function Routine that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e">/// \param bb BB that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:700">run_on_bb</span>(<span style="color:#e06c75">TransformContext</span><span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">ctx</span>, <span style="color:#e06c75">Function</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;*</span> <span style="color:#e06c75">function</span>, <span style="color:#e06c75">analysis</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">bb_t</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">bb</span>) <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// or `cursor-&gt;before(bb-&gt;instructions.at(0)-&gt;node_ref)`
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#c678dd">auto</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">assembler</span> <span style="color:#56b6c2">=</span> <span style="color:#e06c75">function</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">cursor</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">before</span>(<span style="color:#e06c75">bb</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">node_at</span>(<span style="color:#d19a66">0</span>)).<span style="color:#e06c75">value</span>();
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">// or this-&gt;get_var(0/*index */).template value&lt;int&gt;()
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#c678dd">for</span> (<span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">size_t</span> <span style="color:#e06c75">i</span> <span style="color:#56b6c2">=</span> <span style="color:#d19a66">0</span>; <span style="color:#e06c75">i</span> <span style="color:#56b6c2">&lt;</span> <span style="color:#e06c75">mode</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">value</span><span style="color:#56b6c2">&lt;</span><span style="color:#e5c07b">int</span><span style="color:#56b6c2">&gt;</span>(); <span style="color:#56b6c2">++</span><span style="color:#e06c75">i</span>) {
</span></span><span style="display:flex"><span>        <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">nop</span>();
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><h3 id="advanced-usage">Advanced Usage</h3><p>It is also possible to make a transform for more than one type of data at once.</p><p>Each transform, besides the shared/non-shared configurations, also has a so-called <code>FeaturesSet</code>. This mechanism is needed for identifying what transforms implement what callbacks so that we wouldn’t loop through unnecessary data. It means that transform can implement multiple callbacks at the same time.</p><p>For example, I want to transform both Function and <a href="/posts/obfuscator-pt-1/#acronyms">Basic Blocks</a> from a single transform.</p><p>To do that, we need to derive the Transform root class and fill the features set manually.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#c678dd">template</span> <span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">pe</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">any_image_t</span> <span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span>
</span></span><span style="display:flex"><span><span style="color:#c678dd">class</span> <span style="color:#e5c07b">Nops</span> <span style="color:#c678dd">final</span> <span style="color:#56b6c2">:</span> <span style="color:#c678dd">public</span> <span style="color:#e06c75">Transform</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span> {
</span></span><span style="display:flex"><span><span style="color:#c678dd">public</span><span style="color:#56b6c2">:</span>
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// \brief Callback that initializes `features_set_`
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e5c07b">void</span> <span style="color:#e06c75">init_features</span>() <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>        <span style="color:#c678dd">this</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">feature</span>(<span style="color:#e06c75">TransformFeaturesSet</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Index</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">HAS_FUNCTION_TRANSFORM</span>, <span style="color:#e5c07b">true</span>);
</span></span><span style="display:flex"><span>        <span style="color:#c678dd">this</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">feature</span>(<span style="color:#e06c75">TransformFeaturesSet</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Index</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">HAS_BB_TRANSFORM</span>, <span style="color:#e5c07b">true</span>);
</span></span><span style="display:flex"><span>    }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// \brief Optional callback that initializes config variables
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:700">init_config</span>() <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// ... initializing config
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// \brief Transform routine
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param ctx Transform context
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param function Routine that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:700">run_on_function</span>(<span style="color:#e06c75">TransformContext</span><span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">ctx</span>, <span style="color:#e06c75">Function</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;*</span> <span style="color:#e06c75">function</span>) <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// doing something with function here
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// \brief Transform basic block
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param ctx Transform context
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param function Routine that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#7f848e">/// \param bb BB that it should transform
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:700">run_on_bb</span>(<span style="color:#e06c75">TransformContext</span><span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">ctx</span>, <span style="color:#e06c75">Function</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;*</span> <span style="color:#e06c75">function</span>, <span style="color:#e06c75">analysis</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">bb_t</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">bb</span>) <span style="color:#c678dd">override</span> {
</span></span><span style="display:flex"><span>        <span style="color:#7f848e">// doing something with BB
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    }
</span></span><span style="display:flex"><span>
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// Other callbacks you can subscribe to
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:700">run_on_node</span>(<span style="color:#e06c75">TransformContext</span><span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">ctx</span>, <span style="color:#e06c75">Function</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;*</span> <span style="color:#e06c75">function</span>, <span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Node</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">node</span>) <span style="color:#c678dd">override</span> {}
</span></span><span style="display:flex"><span>    <span style="color:#e5c07b">void</span> <span style="color:#61afef;font-weight:700">run_on_insn</span>(<span style="color:#e06c75">TransformContext</span><span style="color:#56b6c2">&amp;</span> <span style="color:#e06c75">ctx</span>, <span style="color:#e06c75">Function</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;*</span> <span style="color:#e06c75">function</span>, <span style="color:#e06c75">analysis</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">insn_t</span><span style="color:#56b6c2">*</span> <span style="color:#e06c75">insn</span>) <span style="color:#c678dd">override</span> {}
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><h3 id="available-info-within-the-transforms">Available info within the transforms</h3><p>From the transform callbacks, you can access information:</p><ul><li>Function<ul><li>Parsed function bounds, info</li><li>LRU registers container</li><li><a href="/posts/obfuscator-pt-1/#acronyms">BB</a> storage</li><li><a href="https://github.com/zyantific/zasm">zasm</a> program</li><li><a href="https://github.com/zyantific/zasm">zasm</a> assembler</li><li>Assembler cursor (the one we used before)</li><li>Analysis observer instance (you can stop/restart it)</li><li><a href="/posts/obfuscator-pt-1/#acronyms">BB</a> internal provider</li><li><a href="https://github.com/zyantific/zasm">zasm</a> machine mode</li><li>Var allocator</li></ul></li><li><a href="/posts/obfuscator-pt-1/#acronyms">Basic Block</a><ul><li><a href="https://github.com/zyantific/zasm">zasm</a> machine mode</li><li>(optional) start/end <a href="/posts/obfuscator-pt-1/#acronyms">RVAs</a></li><li>List of instructions</li><li>List of attached labels (for addressing)</li><li>List of successors</li><li>List of predecessors</li></ul></li><li>Instruction<ul><li>(optional) <a href="/posts/obfuscator-pt-1/#acronyms">RVA</a></li><li>(optional) length in bytes</li><li><a href="https://github.com/zyantific/zasm">zasm</a> instruction reference</li><li><a href="https://github.com/zyantific/zasm">zasm</a> Node reference</li><li>Attached <a href="/posts/obfuscator-pt-1/#acronyms">basic Block</a> reference</li><li>Control flow changes info<ul><li>Type:<ul><li><code>JCC_CONDITION_MET</code></li><li><code>JCC_CONDITION_NOT_MET</code></li><li><code>JMP</code></li></ul></li><li>Destination <a href="/posts/obfuscator-pt-1/#acronyms">BB</a></li></ul></li><li>Relocations info<ul><li>Type:<ul><li><code>HEADER</code></li><li><code>IP</code></li></ul></li><li>Immediate value <a href="/posts/obfuscator-pt-1/#acronyms">RVA</a></li><li>Offset from instruction</li></ul></li><li>Internal analysis flags</li><li>Flags:<ul><li>Type:<ul><li><code>set_0</code></li><li><code>set_1</code></li><li><code>modified</code></li><li><code>tested</code></li><li><code>undefined</code></li></ul></li><li>Values:<ul><li>CF (Carry Flag)</li><li>PF (Parity Flag)</li><li>AF (Adjust Flag)</li><li>ZF (Zero Flag)</li><li>SF (Sign Flag)</li><li>TF (Trap Flag) - for single stepping</li><li>IF (Interrupt Enable Flag)</li><li>DF (Direction Flag)</li><li>OF (Overflow Flag)</li><li>IOPL1 (I/O Privilege Level flag, first bit)</li><li>IOPL2 (I/O Privilege Level flag, second bit)</li><li>NT (Nested Task Flag)</li><li>RF (Resume Flag) - used to control the processor’s response to debug exceptions</li><li>VM (Virtual 8086 Mode Flag)</li><li>AC (Alignment Check or Access Control Flag)</li><li>VIF (Virtual Interrupt Flag)</li><li>VIP (Virtual Interrupt Pending)</li><li>ID (ID flag) - indicates if CPUID instruction can be used</li></ul></li></ul></li></ul></li></ul><p><em>(probably I forgot to mention something as there is really a lot of info)</em></p><h2 id="transform-scheduling">Transform scheduling</h2><p>Transformations are stored per architecture, so if you need to add transform only x86 or only x64 code - you absolutely can do that.</p><h3 id="scheduling">Scheduling</h3><p>Each transform has its unique <code>size_t</code> identifier, which is computed at the compilation time using some cpp <code>__FUNCSIG__</code> magic.
After the config was parsed, we need to actually schedule the transforms, and to do that, we have an interface to search through all transforms using their name and/or <code>size_t</code> identifier.</p><p>Also worth mentioning is that transforms would be applied in the same order as you enable them.</p><h3 id="applying">Applying</h3><p>Since we have four transform callbacks, we have to iterate through all the things exactly four times.
You may think that the iterations through nodes/instructions/<a href="/posts/obfuscator-pt-1/#acronyms">bbs</a> could be optimized and done only once, but you would be wrong, as that would break the appliance order</p><p>For each callback, the obfuscator creates a new <code>TransformContext</code> instance. For now, context only has a <code>rerun_me</code> var, that you can set to true in your callback and the obfuscator would re-run this callback.</p><h2 id="transforms">Transforms</h2><p>Now that we’ve finished with all the analysis phases, it’s finally time to discuss the multiple transforms that I implemented.</p><h3 id="bogus-control-flow">Bogus control flow</h3><p>An obfuscation that inserts an <a href="/posts/obfuscator-pt-1/#acronyms">opaque predicate</a> to the <a href="/posts/obfuscator-pt-1/#acronyms">Basic Block</a> thus creates a second “dummy” successor branch of the <a href="/posts/obfuscator-pt-1/#acronyms">Basic Block</a>, that will never be executed.</p><p>An opaque predicate is an expression that would always be evaluated to one result. To generate these opaque predicates I chose a weird approach.</p><p>To be precise, I used <a href="https://github.com/Z3prover/z3">z3</a> to generate <a href="/posts/obfuscator-pt-1/#acronyms">tautologies</a>. This is not ideal and all of these generated <a href="/posts/obfuscator-pt-1/#acronyms">tautologies</a> in the end are mostly discarding bits, but it was a nice thing to implement.</p><p>To generate a tautology my script has a set of operations that it could apply on a <code>uint32_t</code> value, then it checks whether there are values that would produce different results.</p><p>Since these expressions are mostly discarding bits, most of the decompilers could easily optimize these expressions. I have a couple of mitigations that I could imply for it and how to modify the generator script for the next parts of the series.</p><p>Sample output that I used and converted for <code>zasm</code>’s assembler:</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span>((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">16</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">6</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">0</span>
</span></span><span style="display:flex"><span>((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">16</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">7</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">0</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">+</span> <span style="color:#d19a66">2</span>) <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">4</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">6</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">0</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">+</span> <span style="color:#d19a66">6</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">3</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">12</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">0</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">9</span>) <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">1</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">4</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">0</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">3</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">4</span>) <span style="color:#56b6c2">+</span> <span style="color:#d19a66">4</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">4</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">1</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">1</span>) <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">9</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">0</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">16</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">6</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">6</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">0</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">2</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">2</span>) <span style="color:#56b6c2">^</span> <span style="color:#d19a66">2</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">2</span>
</span></span><span style="display:flex"><span>(((<span style="color:#e06c75">x</span> <span style="color:#56b6c2">&lt;&lt;</span> <span style="color:#d19a66">9</span>) <span style="color:#56b6c2">^</span> <span style="color:#d19a66">11</span>) <span style="color:#56b6c2">&amp;</span> <span style="color:#d19a66">11</span>) <span style="color:#56b6c2">==</span> <span style="color:#d19a66">11</span>
</span></span><span style="display:flex"><span><span style="color:#7f848e">// ...
</span></span></span></code></pre></div><p>There is also a <code>mode</code> variable that I added, which could also instead of generating <a href="/posts/obfuscator-pt-1/#acronyms">opaque predicates</a> generate a math expression using <code>mathop</code>, check for a random value and make two identical <a href="/posts/obfuscator-pt-1/#acronyms">BBs</a>. This will result in semantically the same code execution, although the output in decompilers would look quite messy because it would treat them as different paths of code, although they’re doing the same thing.</p><p><img src="/posts/obfuscator-pt-1/pics/bcf.png" alt="bcf"></p><h4 id="substitution">Substitution</h4><p>An obfuscation that transforms a math expression, to its equivalent that could look a bit more confusing for the <a href="/posts/obfuscator-pt-1/#acronyms">reverse engineer</a>.
A good example of such transformation is an expression <code>x + y</code> that would be then transformed to <code>x - (-y)</code></p><p>A good thing about this transform is that we can run it multiple times and each time it would obscure the expressions even more.</p><p>So far implemented substitutions are:</p><ul><li>x + y = x - (-y)</li><li>x - y = x + (-y)</li><li>x &amp; y = ((x ^ ~y) &amp; x)</li></ul><p><img src="/posts/obfuscator-pt-1/pics/substitution.png" alt="substitution"></p><h4 id="constant-encryption">Constant encryption</h4><p>An obfuscation that “encrypts” your constant immediate values (by using math expressions), and then decrypts it at the run time.</p><p><code>mathop</code> was implemented exactly for this transform. We are using it to generate a random math expression, pass the immediate value to it, emulate it and then convert all the revert operations to a native code.</p><p><img src="/posts/obfuscator-pt-1/pics/constants.png" alt="constants"></p><p>But by default, this is not enough, because in 2023 all decompilers have a symbolic execution and optimizations for such expressions and I was thinking about how to</p><ul><li>Break symbolic execution in <a href="https://binary.ninja/">binja</a></li><li>Break symbolic execution in <a href="https://hex-rays.com/">IDA</a></li></ul><h5 id="breaking-ida-symbolic-execution">Breaking IDA symbolic execution</h5><p>Breaking optimizations of this expression in <code>IDA</code> was easy enough, I just used <code>xchg</code> instructions to load variables on/from the stack and use it in the decryptions.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="display:flex"><span><span style="color:#7f848e">/// Operand decryption with xchg (unsupported in ida)
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span><span style="color:#c678dd">auto</span> <span style="color:#e06c75">xchg_reencrypt_var</span> <span style="color:#56b6c2">=</span> [<span style="color:#56b6c2">&amp;</span>]<span style="color:#56b6c2">&lt;</span><span style="color:#c678dd">typename</span> <span style="color:#e06c75">Ty</span><span style="color:#56b6c2">&gt;</span>(<span style="color:#e06c75">Ty</span>) <span style="color:#56b6c2">-&gt;</span> <span style="color:#e5c07b">void</span> {
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// Alloc some stack frame where the decrypted var would be stored at
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">push</span>(<span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Imm</span>(<span style="color:#e06c75">rnd</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">number</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">std</span><span style="color:#56b6c2">::</span><span style="color:#e5c07b">int16_t</span><span style="color:#56b6c2">&gt;</span>()));
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// Push encrypted constant
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">mov</span>(<span style="color:#e06c75">xchg_enc_holder</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">root_gp</span>(), <span style="color:#e06c75">zasm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">Imm</span>(<span style="color:#e06c75">imm</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">value</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Ty</span><span style="color:#56b6c2">&gt;</span>()));
</span></span><span style="display:flex"><span>    <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">push</span>(<span style="color:#e06c75">xchg_enc_holder</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">root_gp</span>());
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// Pop the encrypted val
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">pop</span>(<span style="color:#e06c75">xchg_enc_holder</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">root_gp</span>());
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// Push it on stack with xchg operation
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">xchg</span>(<span style="color:#e06c75">qword_ptr</span>(<span style="color:#e06c75">easm</span><span style="color:#56b6c2">::</span><span style="color:#e06c75">sp_for_arch</span><span style="color:#56b6c2">&lt;</span><span style="color:#e06c75">Img</span><span style="color:#56b6c2">&gt;</span>()), <span style="color:#e06c75">xchg_enc_holder</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">root_gp</span>());
</span></span><span style="display:flex"><span>    <span style="color:#7f848e">/// Load to register
</span></span></span><span style="display:flex"><span><span style="color:#7f848e"></span>    <span style="color:#e06c75">assembler</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">pop</span>(<span style="color:#e06c75">xchg_enc_holder</span><span style="color:#56b6c2">-&gt;</span><span style="color:#e06c75">root_gp</span>());
</span></span><span style="display:flex"><span>};
</span></span></code></pre></div><p><img src="/posts/obfuscator-pt-1/pics/ida_xchg.png" alt="ida_xchg"></p><h5 id="breaking-binja-symbolic-execution">Breaking BInja symbolic execution</h5><p>Breaking optimizations in <a href="https://binary.ninja/">binja</a> was pretty tough(without using any <a href="/posts/obfuscator-pt-1/#acronyms">CF</a> tricks) so definitely a big shout out to Vector35.</p><p>Initially, it was optimizing <strong>all</strong> the things I tried and then I decided to change my approach.</p><p>The general idea when you’re trying to break a decompiler is to find a bug in its optimizations and/or microcode operations. To do that, I decided to try some uncommon x86 instructions. So I opened an x86 instruction set on <a href="https://en.wikipedia.org/wiki/X86_instruction_listings">wiki</a> and the first one that I tried was <code>ADC</code>, which adds two registers and the carry flag value. And when I added this to the decryption stubs, <a href="https://binary.ninja/">binja</a> suddenly stopped optimizing my math expressions! This was pretty cool but while observing its behavior I noticed that in its decompiled code it always writes <code>a+b+0</code> without checking whether the carry flag was set to 0 or not. To break the decompilation on <a href="https://binary.ninja">binja</a> even more I decided to <strong>always</strong> set the carry flag to 1 and account it in my decryption stub. Which results in <code>a+b+1</code>, but <a href="https://binary.ninja/">binja</a> would write it as <code>a+b+0</code>. Thus, the decompilation code is incorrect.</p><p><img src="/posts/obfuscator-pt-1/pics/binja_bug.png" alt="binja_bug"></p><h4 id="breaking-decompilers">Breaking decompilers</h4><p>Since we already broke the decompiler code generation in <a href="https://binary.ninja">binja</a>, it would be cool to also break the decompilation of any other popular decompilers.</p><p>To do that, there’s no general advice or something like this, you just have to try obscure things until it starts giving errors.</p><p>Funny enough, both of these tricks are kind of related, they all abuse the negative address ranges.</p><h5 id="ida">IDA</h5><p>To achieve the IDA decompilation errors we can abuse the unhandled negative values in the <code>ENTER</code> instruction.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">ENTER</span> <span style="color:#d19a66">0xFFFF</span>, <span style="color:#d19a66">0xFF</span>
</span></span></code></pre></div><p>And this would give us a nice microcode exception while trying to decompile the function.
<img src="/posts/obfuscator-pt-1/pics/microcode_exc.png" alt="microcode_exc"></p><p>But of course, we can’t just append this instruction to any <a href="/posts/obfuscator-pt-1/#acronyms">Basic Block</a> as this would produce a crash on a bare metal too, not only when we decompile this function.</p><p>To “fix” that, I applied the same technique that I used for opaque predicates. It generates the same successor, inserts an opaque predicate, and inserts this instruction somewhere in the new <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> that would never be executed because of the opaque predicate.</p><h4 id="ghidra">Ghidra</h4><p>To cause decompilation errors we can force it to throw errors <a href="https://github.com/NationalSecurityAgency/ghidra/blob/6242fda158fed6c7dbbd6928a4a74371a212c373/Ghidra/Features/Decompiler/src/decompile/cpp/database.cc#L1856">here</a> by trying to access variable beyond the address map.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-diff" data-lang="diff"><span style="display:flex"><span>SymbolEntry *ScopeInternal::addMapInternal(Symbol *sym,uint4 exfl,const Address &amp;addr,int4 off,int4 sz,
</span></span><span style="display:flex"><span>					   const RangeList &amp;uselim)
</span></span><span style="display:flex"><span>{
</span></span><span style="display:flex"><span>  // Find or create the appropriate rangemap
</span></span><span style="display:flex"><span>  AddrSpace *spc = addr.getSpace();
</span></span><span style="display:flex"><span>  EntryMap *rangemap = maptable[spc-&gt;getIndex()];
</span></span><span style="display:flex"><span>  if (rangemap == (EntryMap *)0) {
</span></span><span style="display:flex"><span>    rangemap = new EntryMap();
</span></span><span style="display:flex"><span>    maptable[spc-&gt;getIndex()] = rangemap;
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>  // Insert the new map
</span></span><span style="display:flex"><span>  SymbolEntry::inittype initdata(sym,exfl,addr.getSpace(),off,uselim);
</span></span><span style="display:flex"><span>  Address lastaddress = addr + (sz-1);
</span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700">+ if (lastaddress.getOffset() &lt; addr.getOffset()) {
</span></span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700">+   string msg = "Symbol ";
</span></span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700">+   msg += sym-&gt;getName();
</span></span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700">+   msg += " extends beyond the end of the address space";
</span></span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700">+   throw LowlevelError(msg);
</span></span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700">+ }
</span></span></span><span style="display:flex"><span><span style="color:#98c379;font-weight:700"></span>    
</span></span><span style="display:flex"><span>  list&lt;SymbolEntry&gt;::iterator iter = rangemap-&gt;insert(initdata,addr.getOffset(),lastaddress.getOffset());
</span></span><span style="display:flex"><span>  // Store reference to map in symbol
</span></span><span style="display:flex"><span>  sym-&gt;mapentry.push_back(iter);
</span></span><span style="display:flex"><span>  if (sz == sym-&gt;type-&gt;getSize()) {
</span></span><span style="display:flex"><span>    sym-&gt;wholeCount += 1;
</span></span><span style="display:flex"><span>    if (sym-&gt;wholeCount == 2)
</span></span><span style="display:flex"><span>      multiEntrySet.insert(sym);
</span></span><span style="display:flex"><span>  }
</span></span><span style="display:flex"><span>  return &amp;(*iter);
</span></span><span style="display:flex"><span>}
</span></span></code></pre></div><p>Achieving this is easy enough, all we have to do is <a href="/posts/obfuscator-pt-1/#acronyms">dereference</a> something at <code>-1</code>.</p><div class="highlight"><pre tabindex="0" style="color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="display:flex"><span><span style="color:#61afef;font-weight:700">mov</span>     <span style="color:#e06c75">r13</span>, <span style="color:#d19a66">0xffffffffffffffff</span>
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">lea</span>     <span style="color:#e06c75">r13</span>, [<span style="color:#e06c75">r13</span>]
</span></span><span style="display:flex"><span><span style="color:#61afef;font-weight:700">mov</span>     <span style="color:#e06c75">r8</span>, <span style="color:#e06c75">qword</span> [<span style="color:#e06c75">r13</span>]
</span></span></code></pre></div><p><img src="/posts/obfuscator-pt-1/pics/ghidra_oob.png" alt="ghidra_oob"></p><h2 id="producing-output-binary">Producing output binary</h2><p>At this point, all the transforms have been already applied and the only thing that we need to do is to link the function code, erase the original code and produce an output binary.</p><h3 id="linking">Linking</h3><p>Before linking, the obfuscator estimates the whole code size of all obfuscated functions and creates a new <code>READ/EXECUTE</code> <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> section.</p><p>Then, when we know the base address of the new section, we can start linking obfuscated functions.</p><p>This process is actually <strong>way</strong> easier than I thought it would be, because of how good <a href="https://github.com/zyantific/zasm">zasm</a> is. The only thing I needed to do was to just call some functions to encode the program and it even gave me the list of relocations!</p><h3 id="rebuilding-pe">Rebuilding PE</h3><p><a href="/posts/obfuscator-pt-1/#acronyms">PE</a> rebuilding was a bit harder than linking because it required me to write all the code by myself.</p><p>After all the previous stages we already have all the parsed <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> information and all the new sections, all we need to do is create an output <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> file.</p><h4 id="relocations-update">Relocations update</h4><p>Before updating relocations, it might be a good thing to erase previous ones and erase the whole section that contains it(if needed). To do that, we have to iterate through all the sections of the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> and find the one that contains relocations. Afterward, we need to fill it with zeroes and check whether we filled all sections with zeros.</p><p>Now, we need to assemble the new relocations to our new section with relocations. This is quite trivial because all we need to do is sort them by their base <a href="/posts/obfuscator-pt-1/#acronyms">RVAs</a> and then just serialize them as <code>uint16_t</code>.</p><h4 id="header-initialization">Header initialization</h4><p>Before copying all the sections, we have to initialize the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> header, update its size, and reserve a new buffer size.</p><p>That’s pretty much what it’s doing with buffer at this stage.</p><h4 id="copy-sections">Copy sections</h4><p>Now, we need to reassemble all the sections. To do that we just iterate through all stored sections and just copy their data at their <code>raw_ptr</code>.</p><p>Afterward, it is crucial to assemble new section headers, as that is what OS is using to identify sections. I don’t want to go into much detail about how it’s implemented because it’s very trivial and the code is self-explanatory.</p><h4 id="checksum-update">Checksum update</h4><p>To keep track of the consistency of the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> image, there’s a <code>Checksum</code> field in the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> header. Which is calculated by adding all the <code>uint16_t</code> chunks of the <a href="/posts/obfuscator-pt-1/#acronyms">PE</a> header. You can refer to the <a href="https://github.com/can1357/linux-pe">linux-pe</a> sources to check the implementation of this algorithm.</p><p>All processes are complete! Now, write the output binary to the disk and exit.</p><h1 id="why-this-project-is-better">Why this project is better</h1><p>In the preface, I said that some existing public <a href="/posts/obfuscator-pt-1/#acronyms">bin2bin</a> obfuscators are not well-designed and have limited scalability. This implies that my project, in contrast, has better scalability, and this is indeed the case.</p><p>If we compare the current state of the obfuscator to other publicly available open-source similar projects, we can see that most of these projects are missing a lot of the crucial analysis parts, even <a href="/posts/obfuscator-pt-1/#acronyms">BB</a> decomposition which is needed for a lot of <a href="/posts/obfuscator-pt-1/#acronyms">CF</a> transforms. As a result, adding new features to these projects wouldn’t be as straightforward.</p><p>In terms of features, the alternatives might surpass my project. However, this gap of features could be filled, and re-implementing all of these common features in my obfuscator wouldn’t require much effort due to the efficient design of its core.</p><p>While my project isn’t perfect and lacks many features and analysis features, making it non-competitive with leaders of this market like <a href="https://oreans.com/">Themida</a> or <a href="https://vmpsoft.com/">VMProtect</a>, I believe it serves as a solid foundation for further development and could potentially grow into something much larger.</p><h1 id="plans-for-the-future">Plans for the future</h1><p>The only plan for the future is to complete the tests that I started writing but didn’t have time to finish due to time constraints.</p><p>After completing the tests, I will likely start improving the analysis and/or transforms. We’ll see how it goes.</p><h1 id="final-words">Final words</h1><p>That’s it for the first part of this series. You can follow the development of this project on its <a href="https://github.com/es3n1n/obfuscator">GitHub Repo</a> <em>(stars and PRs are welcome)</em> or on my <a href="https://twitter.com/es3n1n">Twitter</a>. I have quite a lot of ideas that I want to implement before writing and releasing the second part, so it may take some time.</p><h1 id="acronyms">Acronyms</h1><table><thead><tr><th>Short form</th><th>Description</th></tr></thead><tbody><tr><td>ASLR</td><td>Address Space Layout Randomization</td></tr><tr><td>BB or Basic Block</td><td>A sequence of instructions with no branches except into the block and out of the block</td></tr><tr><td>CF</td><td>Control Flow</td></tr><tr><td>Disasm</td><td>Disassembler, a tool that converts machine code into assembly language</td></tr><tr><td>ELF</td><td>Executable and Linkable Format, a common file format for executables, object code, shared libraries, and core dumps in Unix systems</td></tr><tr><td>EFLAGS</td><td>Extended Flags Register in x86 architecture</td></tr><tr><td>GCC</td><td>GNU Compiler Collection, a set of compilers for various programming languages</td></tr><tr><td>GP</td><td>General Purpose (commonly referring to GP registers in computing)</td></tr><tr><td>IP</td><td>Instruction Pointer, a register that stores the address of the next instruction to be executed</td></tr><tr><td>JCC</td><td>Jump if Condition is met (Conditional Jump)</td></tr><tr><td>JE</td><td>Jump if Equal</td></tr><tr><td>JMP</td><td>Unconditional Jump instruction</td></tr><tr><td>JNE</td><td>Jump if Not Equal</td></tr><tr><td>JNZ</td><td>Jump if Not Zero</td></tr><tr><td>JZ</td><td>Jump if Zero</td></tr><tr><td>JumpTable</td><td>A method used in programming to jump to code based on the value of an index, especially in switch statements</td></tr><tr><td>MAP</td><td>Memory Allocation Map or Module Address Plan</td></tr><tr><td>MSVC</td><td>Microsoft Visual C++, an integrated development environment product from Microsoft</td></tr><tr><td>Operand</td><td>A value (an argument) on which the instruction, named by mnemonic, operates</td></tr><tr><td>PDB</td><td>Program Database, a proprietary file format (developed by Microsoft) for storing debugging information</td></tr><tr><td>PE</td><td>Portable Executable, a file format for executables, object code, and DLLs in 32-bit and 64-bit versions of Windows operating systems</td></tr><tr><td>RET</td><td>Return instruction in assembly language</td></tr><tr><td>RIP</td><td>Register Instruction Pointer in x86-64 architecture</td></tr><tr><td>RVA</td><td>Relative Virtual Address</td></tr><tr><td>Root GP</td><td>Root of General Purpose, often referring to the base of general-purpose operations or registers</td></tr><tr><td>SP</td><td>Stack Pointer, a special purpose register that points to the top of the stack</td></tr><tr><td>WinAPI</td><td>Windows Application Programming Interface, a core set of Microsoft’s APIs available in the Microsoft Windows operating systems</td></tr><tr><td>Assembler</td><td>A program that converts assembly language into machine code</td></tr><tr><td>bin2bin</td><td>Short for binary to binary, typically referring to transformations or translations between binary forms</td></tr><tr><td>demangler</td><td>A tool used to convert mangled names back to their original form in programming</td></tr><tr><td>dereference</td><td>The process of accessing the value that a pointer refers to in programming</td></tr><tr><td>disassemble</td><td>The process of converting machine code into assembly code</td></tr><tr><td>disassembling</td><td>The act of breaking down compiled byte code back into a more readable format (such as assembly language)</td></tr><tr><td>opaque predicate</td><td>A predicate in decision-making code whose truth value is always known at compile time, used in obfuscation</td></tr><tr><td>predecessors</td><td>Elements or nodes in a computational construct that come before a given element in a sequence or structure</td></tr><tr><td>reverse engineering</td><td>The process of deconstructing a man-made object to reveal its designs, architecture, or to extract knowledge from the object</td></tr><tr><td>successors</td><td>Elements or nodes in a computational construct that come after a given element in a sequence or structure</td></tr><tr><td>tautologies</td><td>Statements that are true in every possible interpretation in formal logic</td></tr></tbody></table></div><div class="post-tags"><nav class="nav tags"><ul class="flat"><li><a href="/tags/obfuscation">obfuscation</a></li><li><a href="/tags/cpp">cpp</a></li></ul></nav></div></div><div class="footer wrapper"><nav class="nav"><div>Copyright © Arsenii es3n1n 2024 | <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div></nav></div><script>feather.replace()</script></body></html>